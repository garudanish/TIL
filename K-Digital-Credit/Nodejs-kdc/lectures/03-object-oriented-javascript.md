## 객체 지향의 특징

자바스크립트는 완전한 객체지향 언어다.

객체 지향 개념은 다음과 같은 요소를 갖는다.

- 클래스
- 객체
- 메소드
- 속성
- 캡슐화
- 집합
- 재사용
- 상속
- 변형

하지만 자바스크립트는 다른 객체 지향 언어인 C++이나 자바와는 조금 다르다. C++, 자바는 클래스 기반의 언어이고, **자바스크립트는 프로토타입 기반의 언어**이다.

## 객체

하나의 객체는 '어떤 것'을 의미하며, 실생활에서 접하는 어떤 것도 될 수 있다.

객체 지향 컨셉에서 이름, 나이, 키... 등과 같은 대상의 특성은 객체의 속성(Property)이라고 하며, 대상의 동작은 객체의 메서드(Method)라고 한다.

```js
var parkJiSeong = {
  name: "Park Jiseong",
  height: 178,
  weight: 70,
  position: "RW",
  team: "Jeonbuk Hyundai Motors",
};

console.log(ParkJiSeong.team); // "Jeonbuk Hyundai Motors"
```

## 클래스

객체 지향에서 클래스라는 개념은 일종의 틀이다. 클래스가 붕어빵 틀이라면, 객체는 그 틀로 찍어낸 붕어빵이다.

객체는 인스턴스(Instance)라는 말로도 쓰인다. 위의 박지성 객체 예시는 "축구선수라는 클래스로 만들어진 인스턴스"라고 할 수 있다.

같은 클래스를 이용해 서로 다른 객체들을 만들어낼 수 있으며, 이때 클래스는 템플릿처럼 사용된다. 축구선수라는 클래스를 기반으로 뮬리치, 박수일, 김영광같은 또 다른 축구 선수 객체를 만들어낼 수 있다.

자바스크립트에선 암묵적으로 함수의 첫 글자를 대문자로 설정하면 객체로 선언한 것임을 알리는 것이다.

```js
var FootballPlayer = function () {};
FootballPlayer.prototype = {
  name: String,
  age: Number,
  height: Number,
  weight: Number,
  position: String,
  team: String,
};

var parkJiSeong = new FootballPlayer();
parkJiSeong.name = "Park Jiseong";
parkJiSeong.age = 31;
parkJiSeong.height = 178;
parkJiSeong.weight = 70;
```

## 캡슐화

객체가 데이터를 속성에 저장하거나, 저장한 데이터를 이용하여 무엇인가를 수행하는 메서드를 포함하는 것. 정보 은닉이라는 용어를 쓰기도 한다.

만일 서드파티 라이브러리를 이용해 객체를 생성하고, 그 객체의 메서드를 호출한다면 그 메서드가 어떤 코드로 이루어져있는지, 어떻게 작동하는지에 대해서는 큰 관심이 없을 것이다. 그러한 정보들은 숨겨져있다. 컴파일되어 제공될 경우 소스 코드를 살펴볼 수도 없다.

캡슐화는 메서드와 속성의 가시성에 대한 특성도 가지고 있다. 다른 언어에서는 `public`, `private`, `protected` 등의 키워드로 접근 권한을 다르게 설정하고, 자바스크립트에서는 이러한 키워드가 따로 지원되진 않지만 객체의 프라이버시를 위해 데이터를 보호할 수 있는 방법은 존재한다.

## 집합

객체 지향 컨셉에서, 여러 객체를 하나의 새로운 것으로 구성하는 것을 **집합(Aggregation)** 또는 **구성(Composition)**이라고 한다.

이 컨셉은 해결하고자 하는 문제를 개발자가 쉽게 다룰 수 있을 만한 부분으로 쪼개어 해결할 수 있도록 해준다. 즉, 개발할 내용을 몇 가지 계층으로 추상화시킬 수 있고, 이 추상화의 개념은 컴퓨터 시스템에서 문제를 다루는 데 있어 가장 중요한 개념 중 하나다.

집 객체를 한 번에 만드는 게 아니라, 지붕, 기둥, 문 ... 등의 객체를 만든 뒤 각 객체를 합쳐서 하나의 객체로 만드는 것이 집합이다.

## 상속

축구 선수 클래스는 인간 클래스의 속성과 메서드를 포함하고 있다. 즉, 클래스 '축구선수'는 클래스 '인간'을 상속받았다.

## 스코프

스코프는 전역 스코프와 지역 스코프로 정의할 수 있다.

- 전역 스코프: 코드 어디에서든지 참조할 수 있음
- 지역 스코프: 함수 내, 혹은 블록 내 정의된 것으로 정의된 함수 혹은 정의된 블록 내에서만 참조할 수 있음.

`var`로 선언한 변수는 다른 언어들과는 달리 함수 레벨 스코프여서, 함수 블록 내에서 선언된 변수는 함수 블록 내에서만 유효하고 함수 외부에서는 참조할 수 없다.

```js
function foo() {
  if (true) {
    var a = 0;
    console.log(a);
  }
  console.log(a);
}
foo(); // 0 0
```

`a`는 `if`문의 블록 안에서 선언되었지만 함수 블록 안이기 때문에 `if`문 밖에서도 접근할 수 있다.

ES6부터 `const`와 `let`을 통해 블록 레벨 스코프도 지원한다.

## 전역 스코프와 함수 레벨 스코프

함수 레벨 스코프는 함수 내의 범위로, 각 함수마다 자신의 지역 스코프를 가지고 있다. 어떤 함수 내의 지역 스코프에 선언된 변수가 있다면, 그 함수를 벗어난 범위에서는 그 변수를 참조할 수 없다.

```js
var globalScope = "global";

var localFunction = function () {
  var localScope = "local";
  console.log(globalScope); // global. 전역 스코프여서 참조 가능.
  console.log(localScope); // local. 함수 내이기 때문에 지역 스코프 참조 가능.
};

console.log(localScope); // 에러. 지역 스코프를 벗어나 참조하고 있음.
```

변수의 이름이 충돌할 가능성이 있으므로, 되도록이면 전역 스코프에 변수 선언을 하지 않는 것이 좋다.

## 유효 범위 체인

함수 안에 함수가 들어있는 경우, 가장 안 쪽의 함수는 바깥쪽의 범위까지 흡수하게 된다. 이러한 메커니즘이 유효 범위 체인, 스코프 체인이다.

외부에서는 안에 있는 함수의 변수를 참조할 수 없지만, 안에 있는 함수에서는 외부 함수의 변수를 사용할 수 있다.

```js
var a = 1;

function outer() {
  var b = 2;
  console.log(a); // 1

  function inner() {
    var c = 3;
    console.log(b); // 2
    console.log(a); // 1
  }
  inner();
}
outer();
console.log(c); // c is not defined. 지역 스코프를 벗어남.
```

위의 예시에서 `a`는 전역 변수, `b`는 `outer` 함수 레벨 스코프, `c`는 `inner` 함수 레벨 스코프이다. `inner` 함수에서는 `a`, `b`에 접근할 수 있지만, `inner` 함수 안에서 선언된 `c`는 `outer`에서도 접근하지 못한다.

## 정적 범위 Lexical Scope

렉시컬 스코프란, 함수를 어디서 호출하는지가 아니라, 어떤 스코프에 선언하였는지에 따라 결정된다는 것이다.

```js
var text = "global";

function foo() {
  console.log(text);
}

function bar() {
  var text = "bar";
  foo();
}
bar();
```

`bar()`에서 `text`를 바꾸고 `foo()`를 실행시키므로 `bar`가 출력될 것 같지만 `global`이 출력된다.

`foo()`에서 출력한 `text`는 전역 변수를 가리키고 있기 때문이다. `foo`에서 `text`를 출력할 때 먼저 자신의 함수 레벨에서 찾아보고, 없으면 전역에서 찾는다.

`bar()`에서 `foo()`를 불러오지만, 함수를 어떤 스코프에 선언하였는지가 중요하다. 스코프는 실행하면서 바뀌는 것이 아니라 처음 작성한 스코프로 결정된다.

## 호이스팅

함수 안에서 변수를 선언할 때 어떤 위치에 있든 함수의 시작 위치로 끌어올리는 현상이다. 단, 선언 부분만 끌어올리고 값을 할당하는 것은 위치 그대로 남아있는다.

```js
function foo() {
  console.log(a); // undefined;
  var a = 100;
  console.log(a); // 100
}
foo();
```

a is not defined 에러가 아니라 `undefined`가 출력된다. 이는 사실 위의 예시가 다음과 같기 때문이다.

```js
function foo() {
  var a;
  console.log(a); // undefined;
  var a = 100;
  console.log(a); // 100
}
foo();
```

## 클로저

"외부 함수의 실행이 끝나고 외부함수가 소멸된 이후에도, 내부 함수가 외부 함수의 변수에 접근할 수 있는 구조"를 클로저라 한다.

자신의 고유 스코프를 가진 상태로 소멸하지 않고 외부 함수에 의해 호출되는 함수를 만드는 것이 클로저이다.
