# 코딩 중 겪는 혼란에 대한 이해

## 코드가 초래하는 세 가지 종류의 혼란

이진수 변환을 하는 세 가지 예시를 통해 코드가 초래하는 세 가지 종류의 혼란에 대해 알아본다.

### 혼란의 첫 번째 유형: 지식의 부족

```APL
2 2 2 2 2 T n
```

APL로 작성된 위 코드가 혼란스러운 이유는 연산자 `T`에 대한 **지식knowledge이 없기 때문**이다.

### 혼란의 두 번째 유형: 정보의 부족

```JAVA
public class BinaryCalculator {
  public static void main(Integer n) {
    System.out.println(Integer.toBinaryString(n));
  }
}
```

첫 번째 예시와는 달리, 프로그래밍을 해본 사람이라면 `toBinaryString()` 메서드를 통해 숫자가 이진수로 변환되는 걸 알 수 있다. 하지만 구체적으로 어떤 일을 수행하는지 모른다면 혼란스러울 수 있다. 즉, 여기서 혼란의 원인은 이 메서드에 대한 **정보Information가 부족하기 때문**이다.

### 혼란의 세 번째 유형: 처리 능력의 부족

```BASIC
1 LET N2 = ABS(INT(N))
2 LET B$ = ""
3 FOR N1 = N2 TO 0 STEP 0
4     LET N2 = INT(N1 / 2)
5     LET B$ = STR$(N1 - N2 * 2) + B$
6     LET N1 = N2
7 NEXT N1
8 PRINT B$
```

변수 이름이나 연산자를 통해 코드가 무슨 일을 하는지 유추할 수는 있지만, 따라가다보면 머릿속에서 모든 과정을 처리하기가 어렵다. 이러한 혼란은 **처리 능력processing power이 부족하기 때문**이다.

코드가 너무 복잡하기 때문에 변수에 임시로 저장되는 값을 모두 다 기억하거나 어떤 동작이 수행되는지 동시에 알기 어렵다. 이해하려면 따로 종이나 코드 옆에 적어둬야 한다.

## 코딩에 영향을 주는 인지 과정

세 가지 서로 다른 종류의 혼란은 각각 서로 다른 종류의 인지 과정과 연관되고, 이 과정은 기억과 관련있다.

지식이 없다는 것은 두뇌의 `장기 기억 공간(long-term memory, LTM)`에 해당 내용이 없다는 것이다. 장기 기억 공간은 기억하는 내용을 반영구적으로 저장하는 곳이다. 지식이 아닌 어떤 정보가 부족할 때는 `단기 기억 공간(short-term memory, STM)`에 해당 내용이 없기 때문이다. 많은 정보를 처리할 때는 `작업 기억 공간(working memory)`에 영향을 미치는데 우리는 사고할 때 이영역을 사용한다.

- 지식의 부족 = LTM의 문제
- 정보의 부족 = STM의 문제
- 처리 능력의 부족 = 작업 기억 공간의 문제

이 세 가지 인지 과정은 코드를 분석할 때뿐만 아니라 코드를 작성하거나 시스템을 설계할때, 문서를 작성할 때와 같이 모든 종류의 인지 활동에 나타난다.

### LTM과 프로그래밍

LTM에 있는 기억은 아주 오랫동안 보관된다. 그 점에서 컴퓨터의 하드 드라이브와 비슷하다.

APL 예제 코드를 읽을 때는 LTM을 가장 많이 사용한다. APL 키워드 `T`의 의미를 알고 있었다면 그것을 LTM으로부터 인출retrieval할 것이다. 이를 통해 언어의 문법에 대한 지식도 중요하다는 사실을 알 수 있다. `T`가 어떤 수의 값을 다른 진법의 수로 변환해주는 함수라는 것을 알면 코드 분석은 간단하다.

### STM과 프로그래밍

STM은 들어오는 정보를 잠시 보관하기 위해 사용된다. STM은 크기에 제한이 있는데, 대체로 그 추정치는 12개를 넘지 않는다고 한다.

자바 코드 예제를 읽을 때 첫 번째 라인을 읽으면 입력 변수 `n`이 정수라는 것을 알게 된다. 함수가 무슨 일을 하는지는 몰라도 `n`이 정수형 숫자라는 것은 기억하면서 계속 읽어나간다. STM에 `n`이 정수형 숫자라는 사실을 일정 기간 보관한다. 두 번째 라인을 읽으며 `toBinaryString()`이 반환하는 결과가 무엇인지 알 수 있다. 이 함수가 어떤 일을 하는지 파악했더라도, 빠르게 잊어버릴 수도 있다. 함수가 하는 일을 이해하고 나면 STM은 그 내용을 기억에서 지워버린다.

책의 예제에는 `public static void mian`이라고 고의로 오타를 적어놨는데, 이는 STM과 LTM이 동시에 작용한다는 것을 보여주기 위함이다. `mian`이라는 오타는 STM에 저장되지만, `main`이라는 과거의 경험으로 인해 LTM으로 저장되어 있는 이름을 사용하는 것이다.

### 작업 기억 공간과 프로그래밍

실제 사고 작용은 LTM, STM이 아닌 작업 기억 공간에서 일어난다. 생각, 아이디어, 해결책같은 것들이 여기에서 만들어진다. LTM이 하드 드라이브, STM이 메인 메로리라면 작업 기억 공간은 두뇌의 프로세서다.

베이직 언어 예제 프로그램에서 `LET`, `EXIT` 키워드를 볼 때는 LTM을 사용하고, `B$` 변수가 빈 문자열로 시작한다는 정보는 STM에 저장한다. 그리고 코드를 읽을 때 머릿속에서 코드를 실행해보면서 무슨 일이 일어나는지 이해하려 시도한다. 이 과정을 **트레이싱traicing, 추적**이라고 부른다.

## 인지 과정들의 상호작용

- LTM: 오랜 시간에 걸쳐 얻은 정보를 저장하는 장소
- STM: 방금 전에 읽거나 들은 정보를 일시적으로 저장하는 장소
- 작업 기억 공간: 정보를 처리하고 새로운 사고 작용을 형성하는 곳

이 셋은 밀접하게 연관되어 있다.

### 인지 과정들이 어떻게 상호 작용하는지에 대한 간단한 설명

자바 예제를 읽을 때, `n`이 정수형이라는 정보는 STM에 저장하고, 정수 그 자체에 대한 정보는 LTM에서 인출한다. 프로그램이 무엇을 하는지 파악하는 일은 작업 기억 공간에서 이루어진다. 이런 상호작용은 코드를 분석할 때뿐만아니라 프로그래밍과 관련한 다른 종류의 업무에서도 일어난다.

### 프로그래밍 업무와 관련한 인지 과정

버그 리포트를 받는다고 하자. 버그를 고치려면 몇 개월 전 작성한 코드를 읽어야 한다. 이때 읽는 내용은 STM에 저장되고, 동시에 몇 개월 전 구현한 내용을 LTM에서 가져온다. 보고된 유사한 버그의 해결법 같은 정보 역시 LTM에 저장돼 있다.
