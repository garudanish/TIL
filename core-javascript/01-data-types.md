# 데이터 타입

> 코어 자바스크립트

## 1.1 데이터 타입의 종류

자바스크립트의 데이터 타입에는 크게 기본형(원시형, primitive type)과 참조형(reference type) 두 가지가 있다.

- 기본형: 숫자 number, 문자열 string, 불리언 boolean, `null`, `undefined` 등
  - 심볼 Symbol이 ES6에서 추가됐다.
  - 기본형은 **값이 담긴 주솟값을 바로 복제**한다.
- 참조형: 객체 object가 있고, 배열 Array, 함수 Function, 날짜 Date, 정규표현식 RegExp 등이 객체의 하위 분류이다.
  - `Map`, `WeakMap`, `Set`, `WeakSet` 등이 ES6에서 객체의 하위 분류로 추가됐다.
  - 참조형은 **값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제**한다.

기본형은 불변성 immutability을 띤다.

## 1.2 데이터 타입에 관한 배경지식

### 1.2.1 메모리와 데이터

- 비트 bit: 0 또는 1만 표현할 수 있는 하나의 메모리 조각
  - 각 비트는 고유한 식별자를 통해 위치를 확인할 수 있다.
  - 비트 단위로 위치를 확인하는 것은 매우 비효율적이다. 몇 개씩 묶어 하나의 단위로 여기면 표현할 수 있는 값도 늘어나면서 검색시간을 줄일 수 있다. 하지만 너무 많은 양을 묶으면 낭비되는 비트가 생기기도 한다.
- 바이트 byte: 1바이트는 8비트이다.
  - 1바이트는 256(2^8)개의 값을 표현할 수 있다. 2바이트는 65536(2^16)개의 값을 표현할 수 있다.

자바스크립트는 과거보다 메모리 관리에 대한 압박에서 자유로운 상황에서 등장했다. 그래서 C, C++, 자바 등과 달리 숫자의 경우 정수형인지 부동소수형인지 구분하지 않고 8바이트(64비트)를 확보한다.

모든 데이터는 바이트 단위의 식별자, 정확하게는 **메모리 주솟값 memory address**을 통해 서로 구분하고 연결할 수 있다.

### 1.2.2 식별자와 변수

- 변수 variable: 변할 수 있는 데이터. 숫자, 문자열, 객체, 배열 모두 데이터이다.
- 식별자 identifier: 어떤 데이터를 식별하는 데 사용하는 이름, 즉 변수명.

## 1.3 변수 선언과 데이터 할당

### 1.3.1 변수 선언

```js
var a;
```

이는 "변할 수 있는 데이터를 만든다. 이 데이터의 식별자는 `a`로 한다"라는 뜻이다.

변할 수 있는 데이터이므로 선언할 땐 `undefined`이더라도 나중에 다른 값으로 바꾸면 된다.

변수란 결국 변경 가능한 데이터가 담길 수 있는 공간 또는 그릇이다.

이 명령을 받으면 컴퓨터는 메모리에서 비어있는 공간 하나를 확보한다. 그 공간의 이름(식별자)을 `a`라고 지정한다. 여기까지가 변수 선언 과정이다. 이후 사용자가 `a`에 접근하고자 한다면 컴퓨터는 메모리에서 `a`라는 이름을 가진 주소를 검색해 해당 공간에 담긴 데이터를 반환한다.

### 1.3.2 데이터 할당

```js
var a; // 변수 a 선언
a = "abc"; // 변수 a에 데이터 할당

var a = "abc"; // 변수 선언과 할당을 한 문장으로 표현
```

선언과 할당을 나누어서 명령하든 한 문장으로 명령하든 자바스크립트 엔진은 결국 같은 동작을 수행한다.

`a`라는 이름을 가진 주소에 직접 `abc`를 저장하지 않고, 데이터를 저장하기 위한 별도의 메모리 공간을 다시 확보해서 문자열 `abc`를 저장하고, 그 주소를 변수 영역에 저장한다.

이는 1) 데이터 변환을 자유롭게 할 수 있게 하고, 2) 메모리를 더욱 효율적으로 관리한다.

- 숫자형 데이터는 8바이트의 공간을 확보하지만, 문자열은 특별히 정해진 규격이 없다. 언어마다 한 글자당 필요한 메모리 용량이 가변적이며, 전체 글자 수 역시 가변적이기 때문이다.
  - 확보된 공간 안에서만 데이터 변환할 수 있다면, 데이터를 다시 저장하기 위해 확보된 공간을 변환된 데이터 크기에 맞게 늘려야 한다.
  - 만일 메모리 상 중간에 있는 데이터라면 공간을 늘리느라 뒤에 저장된 데이터들이 밀려나고, 밀려난 주소에 맞게 식별자를 다시 연결해야 한다.
  - 변수와 데이터를 별도 공간에 나누어 저장하는 것이 문자열 데이터 변환 처리에 효율적이다.
  - 기존 문자열에 어떤 변환을 가하든 상관없이, 컴퓨터는 **변환된 문자열을 새로 만들어 별도의 공간에 저장**한다.
- 같은 숫자 데이터를 갖는 변수가 500개라면, 변수를 저장하기 위한 500개의 영역을 확보하는 것은 불가피하나, 데이터를 저장하기 위한 영역은 1개만 확보하고 모든 변수가 같은 주소를 가리키게 하는 것이 효율적이다.

## 1.4 기본형 데이터와 참조형 데이터

### 1.4.1 불변값

변수와 상수를 구분하는 성질은 '변경 가능성'이다. 불변값과 상수를 병확히 구분할 필요가 있다.

변수와 상수를 구분 짓는 변경 가능성의 대상은 변수가 저장되는 메모리 영역이다. 한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는지 여부가 관건이다.

반면 불변성 여부를 구분할 때의 변경 가능성의 대상은 데이터가 저장되는 메모리 영역이다.

기본형 데이터인 숫자, 문자열, `boolean`, `null`, `undefined`, `Symbol`은 모두 불변값이다.

```js
var a = "abc";
a = a + "def";

var b = 5;
var c = 5;
b = 7;
```

변수 `a`에 `"abc"`를 할당하고 뒤에 `"def"`를 추가하면 **새로운** 문자열 `"abcdef"`를 만들어 그 주소를 `a`에 저장한다. `"abc"`와 `"abcdef"`는 별개의 데이터이다.

변수 `b`에 숫자 `5`를 할당한다. 컴퓨터는 데이터가 저장되는 메모리 영역에서 `5`를 찾고, 없으면 데이터 공간을 하나 만들어 저장한 뒤 그 주소를 `b`에 할당한다. 변수 `c`에 숫자 `5`를 할당할 땐 데이터 영역에 `5`가 이미 있으니 그 주소를 재활용한다.

변수 `b`의 값을 `7`로 바꿀 때는, 기존 값 `5` 자체를 `7`로 바꾸는 게 아니라 데이터 영역에서 `7`을 찾고 있다면 재활용, 없으면 새로 만들어서 `b`에 할당한다. 결국 `5`와 `7` 모두 다른 값으로 변경할 수 없다.

**변경은 새로 만드는 동작을 통해서만 이루어진다.** 이것이 불변값의 성질이다. 한 번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않는다.

### 1.4.2 가변값

참조형 데이터와 기본형 데이터와의 차이는 '객체의 변수(프로퍼티)를 저장하는 메모리 영역'이 별도로 존재한다는 점이다.

객체의 변수에 들어가는 데이터가 저장되는 영역은 기본형 데이터와 같다. 이 영역에 저장된 값은 모두 불변값이다. 하지만 객체의 변수에는 다른 값을 대입할 수 있다. 이 때문에 참조형 데이터는 불변하지 않다(가변값이다)라고 한다.

```js
var obj1 = {
  a: 1,
  b: "bbb",
};

obj1.a = 2;
```

`obj1`라는 이름을 가진 주소에, `a`라는 이름을 가진 주소와 `b`라는 이름을 가진 주소가 있는 변수 영역을 저장한다. `a` 주소는 `1` 데이터가 저장되어 있는 주소, `b` 주소는 `"bbb"` 데이터가 저장되어 있는 주소를 값으로 가진다.

`obj1`의 `a` 속성을 바꾼다면, `a` 주소는 `2` 데이터가 저장되어 있는 주소로 값을 바꾼다. 이때 변한 것은 `a`가 값으로 가지는 주소이지, `obj1`가 값으로 가지는 주소가 아니다. 즉 새로운 객체가 만들어진 것이 아니라, 기존 객체 내부의 값만 바뀐 것이다.

이때 데이터 영역의 `1`은 자신의 주소를 참조하는 변수의 개수, 즉 참조 카운트가 0이 된다. 참조 카운트가 0인 메모리 주소는 가비지 컬렉터의 수거 대상이 되며, 런타임 환경에 따라 특정 시점 또는 메모리 사용량에 따라 수거된다. 수거된 메모리는 다시 새로운 값을 할당할 수 있는 빈 공간이 된다.

### 1.4.3 변수 복사 비교

```js
var a = 10;
var b = a;

var obj1 = { c: 10, d: "ddd" };
var obj2 = obj1;

b = 15;
obj2.c = 20;
```

기본형 데이터와 참조형 데이터 모두 변수를 복사한 뒤 같은 주소를 바라보게 되는 점은 동일하다. 하지만 데이터 할당 과정의 차이로 복사 이후의 동작에 큰 차이가 발생한다.

`b`에 `15`를 할당할 땐 데이터 영역에 새로 저장하고, 그 데이터가 저장된 주소를 변수 `b`가 저장된 주소에 저장한다.

`obj2`의 `c` 프로퍼티에 `20`을 할당할 땐 `obj2`가 값으로 가지는 `c`, `d` 주소가 있는 영역으로 가서, `20` 데이터를 새로 만들어 그 주소를 `c`가 저장된 주소에 저장한다.

즉, 복사한 변수의 값을 바꿨을 때 기본형 데이터는 변수가 바라보는 주소가 달라지지만, 참조형 데이터는 변수가 바라보는 주소가 달라지지 않는다. `a !== b`이고, `obj1 === obj2`이다.

이 결과가 기본형과 참조형 데이터의 가장 큰 차이점이다.

```js
var obj1 = { c: 10, d: "ddd" };
var obj2 = obj1;

obj1 === obj2; // true

obj2 = { c: 10, d: "ddd" };

obj1 === obj2; // false
```

단, 객체의 내부 프로퍼티(`obj2.c`)를 바꾸는 것이 아니라 `obj2`에 새로운 객체를 할당하면, **변수에 할당되는 값을 직접 변경**하는 것이므로, 데이터 영역의 **새로운 공간에 새 객체가 저장**되고 그 주소가 `obj2`에 저장된다. 이 경우 `obj1`과 동일한 프로퍼티, 동일한 값을 가진다고 해도 값이 달라진다.

즉, 참조형 데이터가 가변값이라고 설명할 때의 '가변'은 참조형 데이터 자체를 변경할 경우가 아니라 그 내부의 프로퍼티를 변경할 때만 성립한다.

## 1.5 불변 객체

### 1.5.1 불변 객체를 만드는 간단한 방법

불변 객체 Immutable object는 최근 React, Vue.js, Angular 등의 라이브러리나 프레임워크에서뿐만 아니라 함수형 프로그래밍, 디자인 패턴 등에서도 매우 중요한 기초가 되는 개념이다.

**참조형 데이터의 가변성은 데이터 자체가 아니라 내부 프로퍼티를 변경할 때만 성립**한다. 데이터 자체를 변경, 즉 새로운 데이터를 할당하면 기존 데이터는 변하지 않는다. 이를 이용해 내부 프로퍼티를 변경할 필요가 있을 때마다 매번 새로운 객체를 만들기로 하거나, 자동으로 새로운 객체를 마드는 도구를 활용한다면 객체 역시 불변성을 확보할 수 있다.

불변 객체는 값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우에 필요하다.

```js
var user = {
  name: "Hyeonsu",
  gender: "male",
};

var changeName = function (user, newName) {
  var newUser = user;
  newUser.name = newName;
  return newUser;
};

var user2 = changeNmae(user, "Kim");
console.log(user.name, user2.name); // Kim Kim
console.log(user === user2); // true
```

정보가 바뀐 시점에 알림을 보내야 하거나, 바뀌기 전과 후의 차이를 보여줘야 하는 기능을 구현하기 어렵다.

```js
var user = {
  name: "Hyeonsu",
  gender: "male",
};

var changeName = function (user, newName) {
  return {
    name: newName,
    gender: user.gender,
  };
};

var user2 = changeNmae(user, "Kim");
console.log(user.name, user2.name); // Hyeonsu Kim
console.log(user === user2); // false
```

`changeName` 함수가 새로운 변수를 반환하도록 수정했다. `user`와 `user2`는 이제 다른 객체이므로 변경 전 후를 비교할 수 있다.

하지만 `user.gender`의 방식으로 변경할 필요가 없는 기존 객체의 프로퍼티를 하드코딩으로 입력했다. 변경할 필요가 없는 프로퍼티가 많아질 수록 번거로울 것이다.

```js
var copyObject = function (target) {
  var result = {};
  for (var prop in target) {
    result[prop] = target[prop];
  }
  return result;
};

var user = {
  name: "Hyeonsu",
  gender: "male",
};

var user2 = copyObject(user);
user2.name = "Kim";

console.log(user.name, user2.name); // Hyeonsu Kim
console.log(user === user2); // false
```

`for in` 문법을 이용해 프로퍼티 개수에 상관없이 모든 프로퍼티를 복사하는 함수 `copyObject`를 만들었다. `user` 내부에 변경이 필요할 때 `copyObject`를 사용하기로 합의하고 그 규칙을 지킨다면 `user`는 불변 객체일 것이다.

하지만 규칙이 반드시 지켜지리라는 보장도 없고, 얕은 복사만을 수행하는 부분이 아쉽다.

### 1.5.2 얕은 복사와 깊은 복사

**얕은 복사 Shallow copy**는 바로 아래 단계의 값만 복사하는 방법이고, **깊은 복사 Deep copy**는 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법이다.

1.5.1의 `copyObject`는 얕은 복사로, 중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값만 복사한다는 의미다. 원본 객체와 복사본 객체가 해당 프로퍼티에 대해 동일한 참조형 데이터의 주소를 가리키게 된다. 복사본을 수정했을 때 원본도 바뀐다.

```js
var user = {
  name: "Hyeonsu",
  urls: {
    github: "http://github.com/garudanish",
    blog: "http://velog.io/@garudanish",
  },
};
var user2 = copyObject(user);

user2.name = "Kim";
console.log(user.name === user2.name); // false

user.urls.github = "http://github.com";
console.log(user.urls.github === user2.urls.github); // true
user2.urls.blog = "http://velog.io";
console.log(user.urls.blog === user2.urls.blog); // true
```

`name` 프로퍼티는 영향을 주지 않지만, `urls`의 내부 프로퍼티는 서로 영향을 주는 것을 알 수 있다.

```js
var user2 = copyObject(user);
user2.urls = copyObject(user.urls);
```

위와 같이 `user.urls` 프로퍼티에 대해서도 불변 객체로 만들면 영향을 주고받지 않는다.

어던 객체를 복사할 때 객체 내부의모든 값을 복사해서 완전히 새로운 데이터를 만들고자 할 때, 프로퍼티가 기본형 데이터일 경우에는 그대로 복사하면 되지만, 참조형 데이터는 그 내부의 프로퍼티들을 복사해야 한다. 참조형 데이터가 있을 때마다 이 과정을 재귀적으로 수행해야 깊은 복사가 된다.

```js
var copyObjectDeep = function (target) {
  var result = {};
  if (typeof target === "object" && target !== null) {
    for (var prop in target) {
      result[prop] = copyObjectDeep(target[prop]);
    }
  } else {
    result = target;
  }
  return result;
};
```

`target`이 참조형 데이터일 경우에는 내부 프로퍼티들을 순회하며 `copyObjectDeep` 함수를 재귀적으로 호출하고, 기본형 데이터일 경우에는 그대로 지정한다. `target !== null` 조건이 붙은 이유는 자바스크립트 자체의 버그로 `typeof null`이 `object`로 반환되기 때문이다.

`hasOwnProperty` 메서드를 활용해 프로토타입 체이닝을 통해 상속된 프로퍼티를 복사하지 않게끔 할 수도 있다. ES5의 getter / setter를 복사하는 방법은 `Object.getOwnPropertyDescriptor`, `Object.getOwnPropertyDescriptors` 외에는 방법이 없다.

객체를 JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 바꾸는 방법으로도 깊은 복사를 할 수 있다. 이 방법은 메서드나 숨겨진 프로퍼티(`__proto__`)나 getter / setter와 같이 JSON으로 변경할 수 없는 프로퍼티들은 무시한다. `httpRequest`로 받은 데이터를 저장한 객체를 복사할 때 등 순수한 정보만 다룰 때 활용하기 좋다.

```js
var copyObjectViaJson = function (target) {
  return JSON.parse(JSON.stringify(target));
};
```

## 1.6 `undefined`와 `null`

자바스크립트에는 '없음'을 나타내는 값으로 `undefined`와 `null` 두 가지가 있다.

`undefined`는 사용자가 명시적으로 지정할 수도 있지만 값이 존재하지 않을 때 자바스크립트 엔진이 자동으로 부여하는 경우도 있다.

자바스크립트 엔진은 사용자가 어떤 값을 지정할 것이라고 예상되는 상황임에도 실제로는 그렇게 하지 않았을 때 `undefined`를 반환한다.

1. 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
2. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
3. `return` 문이 없거나 호출되지 않는 함수의 실행 결과

```js
var a;
console.log(a); // (1) undefined

var obj = { a: 1 };
console.log(obj.b); // (2) undefined

var func = function () {};
var c = func();
console.log(c); // (3) undefined

var arr1 = [];
arr1.length = 3;
console.log(arr1); // (3) [비어 있음 × 3]

var arr2 = new Array(3);
console.log(arr2); // (3) [비어 있음 × 3]

var arr3 = [undefined, undefined, undefined];
console.log(arr3); // (3) [undefined, undefined, undefined]
```

배열의 경우에는 조금 특이한 동작을 확인할 수 있다.

`arr1`과 `arr2`는 배열에 3개의 빈 요소를 확보했지만 확보된 각 요소에서 어떤 값도, 심지어 `undefined`도 할당돼 있지 않았다.
`arr3`는 각 요소에 `undefined`를 할당했고, 출력 결과 역시 다르다.

비어있는 요소와 `undefined`를 할당한 요소는 출력 결과부터 다르다. '비어있는 요소'는 순회와 관련된 많은 배열의 메서드들의 순회 대상에서 제외된다. 둘은 `forEach`, `map`, `filter`, `reduce` 등에서 다르게 동작한다. `undefined`는 순회 대상에 포함되지만, 비어있는 요소는 건너 뛴다.

이는 배열 역시 객체이기 때문에, 존재하지 않는 프로퍼티에 대해서는 순회할 수 없기 때문이다. `length` 프로퍼티의 개수만큼 공간을 확보하고 이름을 지정하는 것이 아니라, 값을 지정할 때 비로소 빈 공간을 확보하고 인덱스를 이름으로 지정하고 데이터의 주솟값으로 저장한다. 값이 지정되지 않은 인덱스는 존재하지 않는 프로퍼티에 지나지 않는다.

데이터 영역의 메모리 주소를 지정하지 않은 식별자에는 자바스크립트가 직접 `undefined`를 할당한다.

`var` 변수는 렉시컬 환경(Lexical Environment) 활성화될 때 생성되면서 동시에 `undefined`로 초기화된다. `let`과 `const`는 `undefined`가 할당하지 않은 채로 초기화를 마치며, 이후 특정 값을 할당하기 전에는 해당 변수에 접근할 수 없다.

비어있음을 명시적으로 나타내고 싶을 때는 `null`을 사용한다.

`typeof null`은 `object`를 반환하는데, 이는 자바스크립트 자체 버그이다. 따라서 어떤 요소가 `null`인지 판별할 때는 `===` 일치 연산자를 사용해야 한다.
