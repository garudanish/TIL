# 사용자 정의 이터러블, 이터러블/이터레이터 프로토콜 정의

```js
const iterable = {
  [Symbol.iterator]() {
    let i = 3;

    return {
      next() {
        return i == 0 ? { done: true } : { value: i--, done: false };
      },
    };
  },
};

const iterator = iterable[Symbol.iterator]();
for (const a of iterator) console.log(a); // 3, 2, 1
```

3부터 1까지의 요소를 순회하는 이터러블을 직접 만들면 위와 같다. 이를 통해 이터레이터를 만들면 직접 만들었지만 `for of`를 통해 순회할 수 있다.

```js
const arr = [1, 2, 3];
const iterator = arr[Symbol.iterator]();
console.log(iterator[Symbol.iterator]() === iterator); // true
```

이터러블로 만들어진 이터레이터 역시 `Symbol.iterator`를 가지고 있고, 이 이터레이터를 실행한 값은 자기 자신이다. 이터레이터가 자기 자신을 반환하는 `Symbol.iterator` 메서드를 가지고 있을 때 Well-formed라고 할 수 있다.

위의 사용자 정의 이터러블이 Well-formed 이터레이터를 반환하도록 만들려면 아래와 같이 수정한다.

```js
const iterable = {
  [Symbol.iterator]() {
    let i = 3;

    return {
      next() {
        return i == 0 ? { done: true } : { value: i--, done: false };
      },
      [Symbol.iterator]() {
        return this;
      },
    };
  },
};
```

`Symbol.iterator`를 실행했을 때 반환한 이터레이터가 자기 자신 또한 이터러블이면서, 자신의 `Symbol.iterator`를 실행했을 때 자기 자신을 반환하게 한다. 이렇게 되면 `next()` 메서드를 실행했을 때 이전의 순회 진행 정도를 기억할 수 있다.
