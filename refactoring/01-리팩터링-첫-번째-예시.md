# Chaptor 01. 리팩터링: 첫 번째 예시

## 1.2 예시 프로그램을 본 소감

- 코드를 수정하려면 사람이 개입되고, 사람은 코드의 미적 상태에 민감하다. 설계가 나쁜 시스템은 수정하기 어렵다.
- 나는 (중략) 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다.
- 새로운 요구사항은 수색 대원처럼 한두 명씩이 아니라 한 부대씩 몰려오기 마련이다.

## 1.3 리팩터링의 첫 단계

- 리팩터링할 코드 영역을 꼼꼼하게 검사해줄 테스트 코드들부터 마련해야 한다.
- 리팩터링하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다.

## 1.4 `statement()` 함수 쪼개기

- 코드 조각을 별도 함수로 추출하는 바식으로 앞서 파악한 정보를 코드에 반영할 것이다.
- 먼저 별도 함수로 빼냈을 때 유효범위를 벗어나는 변수, 즉 새 함수에서는 곧바로 사용할 수 없는 변수가 있는지 확인한다.
- `perf`와 `play`는 추출한 새 함수에서도 필요하지만 값을 변경하지 않기 때문에 매개변수로 전달하면 된다. 한편 `thisamount`는 함수 안에서 값이 바뀌는데, 이런 변수는 조심해서 다뤄야 한다.
- 아무리 간단한 수정이라도 리팩터링 후에는 항상 테스트하는 습관을 들이는 것이 바람직하다. ... 이처럼 조금씩 변경하고 매번 테스트하는 것은 리팩터링 절차의 핵심이다. 한 번에 너무 많이 수정하려다 실수를 저지르면 디버깅하기 어려워서 결과적으로 작업 시간이 늘어난다.
- 함수를 추출하고 나면 추출된 함수 코드를 자세히 들여다보면서 지금보다 명확하게 표현할 수 있는 간단한 방법은 없는지 검토한다. 가장 먼저 변수의 이름을 더 명확하게 바꿔보자.

### play 변수 제거하기

- 이전 코드는 루프를 한 번 돌 때마다 공연을 조회했는데 반해 리팩터링한 코드에서는 세 번이나 조회한다. ... 일단 지금 확인한 바로는 이렇게 변경해도 성능에 큰 영향은 없다.

### 적립 포인트 계산 코드 추출하기

나였다면

```js
function volumeCreditsFor(perf) {
  let volumeCredits = 0;
  volumeCredits += Math.max(perf.audience - 30, 0);
  if ("comedy" === playFor(perf).type)
    volumeCredits += Math.floor(perf.audience / 5);
  return volumeCredits;
}
```

가 아니고, 맨 처음부터 `let volumeCredits = Math.max(perf.audience - 30, 0);`로 선언했을 것 같다.

### format 변수 제거하기

- 임시 변수는 자신이 속한 루틴에서만 의미가 있어서 루틴이 길고 복잡해지기 쉽다.
- 그런데 이름이 마음에 걸린다. `format`은 이 함수가 하는 일을 충분히 설명해주지 못한다. 템플릿 문자열 안에서 사용될 이름이라서 `formatAsUSD`라고 하기에는 또 너무 장황하다.
  - (그래서 `usd()`로 바꿈)
- 이름짓기는 중요하면서도 쉽지 않은 작업이다. **긴 함수를 작게 쪼개는 리팩터링은 이름을 잘 지어야만 효과가 있다.** 이름이 좋으면 함수 본문을 읽지 않고도 무슨 일을 하는지 알 수 있다. 물론 단번에 좋은 이름을 짓기는 쉽지 않다. 따라서 처음에는 당장 떠오르는 최선의 이름을 사용하다가, 나중에 더 좋은 이름이 떠오를 때 바꾸는 식이 좋다.

### volumeCredits 변수 제거하기

- 반복문이 중복되는 것을 꺼리는 이들이 많지만, 이 정도 중복은 성능에 미치는 영향이 미미할 때가 많다. 실제로 이번 리팩터링 전과 후의 실행 시간을 측정해보면 차이를 거의 느끼지 못할 것이다.

나는 성능 걱정이 될 때마다 [https://perf.link/perf.link](https://perf.link/)에서 테스트를 돌려보곤 한다. 그 동안은 두 구현 방법 중 어떤 걸 선택할까를 두고 쓰는 경우가 대부분이었는데, 반복문 중복의 경우도 한 번 써봐야겠다. ![이미지](https://github.com/garudanish/TIL/assets/73154157/04abcc2b-fc95-4eae-8a94-a186b04dd8ac)

## 1.6 계산 단계와 포맷팅 단계 분리하기

- 이때 복사를 한 이유는 함수로 건넨 데이터를 수정하기 싫어서다. 가변 데이터는 금방 상하기 때문에 나는 데이터를 최대한 불변처럼 취급한다.

## 1.7 중간 점검: 두 파일(과 두 단계)로 분리됨

- (코드량이) 늘어난 주된 원인은 함수로 추출하면서 함수 본문을 열고 닫는 괄호가 덛붙었기 때문이다. **그 외에 달라진 점이 없다면 안 좋은 징조**지만, 다행히 그렇지는 않다. 추가된 코드 덕분에 전체 로직을 구성하는 요소 각각이 더 뚜렷이 부각되고, 계산하는 부분과 출력 형식을 다루는 부분이 분리됐다.

단순 함수 추출만 한다고 무조건 좋은 게 아니다.

## 1.10 마치며

- 좋은 코드를 가늠하는 확실한 방법은 '얼마나 수정하기 쉬운가'다.
