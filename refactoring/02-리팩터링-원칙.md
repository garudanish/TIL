# Chaptor 02. 리팩터링 원칙

## 2.1 리팩터링 정의

- 리팩터링의 정의
  - 명사: 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
  - 동사: 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.
- 코드 베이스를 정리하거나 구조를 바꾸는 모든 작업을 '재구성restructuring'이라는 포괄적인 용어로 표현하고, 리팩터링은 재구성 중 특수한 한 형태로 본다.
- 리팩터링하기 전과 후의 코드가 똑같이 동작해야 한다.
- 리팩터링 과정에서 발견된 버그는 리팩터링 후에도 그대로 남아 있어야 한다.
- 리팩터링은 성능 최적화와 비슷하다. 둘 다 코드를 변경하지만 프로그램의 전반적인 기능은 그대로 유지한다. 단지 목적이 다를 뿐이다. 리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다.

## 2.2 두 개의 모자

- 나는 소프트웨어를 개발할 때 목적이 '기능 추가'냐, 아니면 '리팩터링'이냐를 명확히 구분해 작업한다. ... 기능을 추가할 때는 '기능 추가' 모자를 쓴 다음 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다. ... 반면 리팩터링할 때는 '리팩터링' 모자를 쓴 다음 기능 추가는 절대 하지 않기로 다짐한 뒤 오로지 코드 재구성에만 전념한다.

## 2.3 리팩터링하는 이유

- 소프트웨어 설계가 좋아진다.
  - 규칙적인 리팩터링은 코드의 구조를 지탱해줄 것이다.
  - 같은 일을 하더라도 설계가 나쁘면 코드가 길어지기 십상이다 ... 코드량이 줄면 수정하는 데 드는 노력은 크게 달라진다.
- 소프트웨어를 이해하기 쉬워진다.
  - 컴퓨터에게 시키려는 일과 이를 표현한 코드의 차이를 최대한 줄여야 한다.
  - 프로그래밍은 결국 내가 원하는 바를 정확히 표현하는 일이다.
  - 문제는 프로그램을 동작시키는 데만 신경 쓰다 보면 나중에 그 코드를 다룰 개발자를 배려하지 못한다는 데 있다. ... 사실 그 다른 사람이 바로 나 자신일 때가 많다.
- 버그를 쉽게 찾을 수 있다.
- 프로그래밍 속도를 높일 수 있다.
  - 코드 개발 속도를 높일 수 있다.
  - 한 시스템을 오래 개발 중인 개발자들과 얘기하다 보면... 새로운 기능을 추가할 수록 기존 코드베이스에 잘 녹여낼 방법을 찾는 데 드는 시간이 늘어난다는 것이다.
  - 내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다.

## 2.4 언제 리팩터링해야 할까?

- 3의 법칙
  - 처음에는 그냥 한다.
  - 비슷한 일을 두 번째로 하게 되면(중복이 생겼다는 사실에 당황스럽겠지만), 일단 계속 진행한다.
  - 비슷한 일을 세 번째 하게 되면 리팩터링한다.

이른바 '삼진 리팩터링'제
개발 리드님이 말씀해주신 방식과 정확히 동일하다.

- 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
  - 리팩터링하기 가장 좋은 시점은 코드 베이스에 기능을 새로 추가하기 직전이다.
  - 오류를 일으키는 코드가 세 곳에 복제되어 퍼져 있다면, 우선 한 곳으로 합치는 편이 작업하기에 훨씬 편하다.
- 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기
  - 나는 코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다.

뭔 말인지는 알겠는데... 이런 걸 습관적으로 하게 되는 사람이 시니어 개발자, 고수 개발자인 걸까?

- 쓰레기 줍기 리팩터링
  - 항상 처음 봤을 때보다 깔끔하게 정리하고 떠나자.
- 계획된 리팩터링과 수시로 하는 리팩터링
  - 나는 개발에 들어가기 전에 리팩터링 일정을 따로 잡아두지 않고, 기능을 추가하거나 버그를 잡는 동안 리팩터링도 함께 한다.
  - 리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다.
  - 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.
  - 그동안 리팩터링에 소홀했다면, 따로 시간을 내서 새 기능을 추가하기 쉽도록 코드베이스를 개선할 필요가 있다.
  - 리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야 한다.
- 오래 걸리는 리팩터링
  - 리팩터링은 대부분 몇 분 안에 끝난다. 길어야 몇 시간 정도다. 하지만 팀 전체가 달려들어도 몇 주는 걸리는 대규모 리팩터링도 있다.
  - 나는 이런 상황에 처하더라도 팀 전체가 리팩터링에 매달리는 데는 회의적이다. 그보다는 주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적일 때가 많다.
- 코드 리뷰에 리팩터링 활용하기
  - 내 눈에는 명확한 코드가 다른 팀원에게는 그렇지 않을 수 있다.
  - 풀 리퀘스트 모델에서는 그리 효과적이지 않다. ... 이왕이면 참석자가 참석하는 방식이 좋다.
- 관리자에게는 뭐라고 말해야 할까?
  - 기술을 모르는 상당수의 관리자와 고객은 코드베이스의 건강 상태가 생산성에 미치는 영향을 모른다. 이런 상황에 있는 이들에게는 "리팩터링한다고 말하지 말라"라고 조언하겠다.
  - 프로 개발자의 역할은 효과적인 소프트웨어를 최대한 빨리 만드는 것이다. 내 경험상 리팩터링하면 소프트웨어를 빠르게 만드는 데 아주 효과적이다.
  - 일정을 최우선으로 여기는 관리자는 최대한 빨리 끝내는 방향으로 진행하기를 원한다. 그리고 구체적인 방법은 개발자가 판단해야 한다. 프로 개발자에게 주어진 임무는 새로운 기능을 빠르게 구현하는 것이고, 가장 빠른 방법은 리팩터링이다. 그래서 리팩터링부터 한다.
- 리팩터링하지 말아야 할 때
  - 굳이 수정할 필요가 없다면 리팩터링하지 않는다.
    - 내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다.
  - 리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 대도 리팩터링 하지 않는다.

## 2.5 리팩터링 시 고려할 문제

- 새 기능 개발 속도 저하
  - 리팩터링의 궁극적인 목적은 개발 속도를 높이는 데 있다.
  - 리팩터링이 필요해 보이지만, 추가하려는 새 기능이 아주 작아서 기능 추가부터 하고 싶은 상황에 마주칠 수 있다. 이럴 때는 프로 개발자로서 가진 경험을 잘 발휘해서 결정한다.
  - 아직도 리팩터링을 과도하게 하는 경우보다 거의 하지 않는 경우가 훨씬 많다. 다시 말해 대부분은 리팩터링을 더 자주 하도록 노력해야 한다.
  - 리팩터링의 본질은 코드 베이스를 예쁘게 꾸미는 데 있지 않다. 오로지 경제적인 이유로 하는 것이다.
- 코드 소유권
  - 함수를 호출하는 코드의 소유자가 다른 팀이라서 나에게는 쓰기 권한이 없을 수 있다.
  - 그렇다고 리팩터링을 할 수 없는 건 아니다. 여전히 훌륭하게 개선할 수 있지만 제약이 따를 뿐이다.
- 브랜치
  - 풀타임 개발팀이라면 기능별 브랜치가 가져오는 리팩터링 부담은 너무나 크다. 그래서 CI를 완벽히 적용하지는 못하더라도 통합 주기만큼은 최대한 짧게 잡아야 한다.
- 테스팅
  - 리팩터링은 단계별 변경 폭이 작아서 도중에 발생한 오류의 원인이 될만한 코드 범위가 넓지 않다.
  - 핵심은 오류를 재빨리 잡는 데 있다. 실제로 이렇게 하려면 코드의 다양한 측면을 검사하는 테스트 스위트test suite가 필요하다. ... 달리 말하면 리팩터링하기 위해서는 (대부분의 경우에) 자가 테스트 코드를 마련해야 한다는 뜻이다.
  - 리팩터링 과정에서 버그가 생길 위험이 아주 크다는 불안감을 해소할 수 있다.
- 레거시 코드
  - 레거시 시스템을 파악할 때 리팩터링이 굉장히 도움된다.
  - 대규모 레거시 시스템을 테스트 코드 없이 명료하게 리팩터링하기는 어렵다. 이 문제의 정답은 당연히 테스트 보강이다.
  - 그나마 해줄 수 있는 조언은 <레거시 코드 활용 전략>에 나온 지침을 충실히 따르는 것이다.
- 데이터베이스

익스트림 프로그래밍이 뭔지 궁금해졌다. 정보처리기사 시험볼 때 지나가면서 본 것 같은데 자세한 내용은 처음 보는듯.

## 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

- 리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드베이스를 잘 설계해준다는 데 있다.
- 한 가지 방법은 향후 변경에 유연하게 대처할 수 있는 유연성 매커니즘flexibility mechanism을 소프트웨어에 심어두는 것이다. 가령 함수를 정의하다 보면 범용적으로 사용할 수 있겠다는 생각이 들 때가 있다. 그래서 다양한 예상 시나리오에 대응하기 위한 매개변수들을 추가한다. ... [하지만] 유연성 메커니즘이 오히려 변화에 대응하는 능력을 떨어뜨릴 때가 대부분이다.
- 리팩터링을 활용하면 다르게 접근할 수 있다. ... 그저 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다. ... 복잡도를 높일 수 있는 유연성 메커니즘은 반드시 검증을 거친 후에 추가한다.
- 리팩터링을 미루면 훨씬 힘들어진다는 확신이 들 대만 유연성 메커니즘을 미리 추가한다.
- 이런 식으로 설계하는 방식을 간결한 설계, 점진적 설계, YAGNI(애그니, You Aren't Going to Need It) 등으로 부른다.

## 2.7 리팩터링과 소프트웨어 개발 프로세스

- 자가 테스트 코드와 리팩터링을 묶어서 테스트 주도 개발(TDD)이라 한다.
- 애자일을 제대로 적용하려면 리팩터링에 대한 팀의 역량과 열정이 뒷받침되어 프로세스 전반에 리팩터링이 자연스럽게 스며들도록 해야 한다.
- 팀으로 개발하면서 리팩터링을 하려면 각 팀원이 다른 사람의 작업을 방해하지 않으면서 언제든지 리팩터링할 수 있어야 한다.

## 2.8 리팩터링과 성능

- 리팩터링하면 소프트웨어가 느려질 수도 있는 건 사실이다. 하지만 그와 동시에 성능을 튜닝하기는 더 쉬워진다.

이동욱님도 비슷한 말을 했던 것 같다.

![성능 개선은 실제 성능 이슈가 나오고 나서 하는게 좋다.](https://github.com/garudanish/TIL/assets/73154157/e32a7014-aada-41f5-91c9-18256a07de5f)
(출처: 이동욱님 블로그 - ["1. 좋은 함수 만들기 - 부작용과 거리두기"](https://jojoldu.tistory.com/697))

- 대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다는 것이다. 그래서 코드 전체를 고르게 최적화한다면 그중 90%는 효과가 거의 없기 때문에 시간 낭비인 셈이다.
- 리팩터링이 잘 되어 있는 프로그램은 성능을 더 세밀하게 분석할 수 있다. ... 그래서 튜닝하기 쉬워진다.
