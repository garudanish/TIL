# Chaptor 03. 코드에서 나는 악취

## 3.1 기이한 이름

- 코드는 단순하고 명료하게 작성해야 한다.
- 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 엄청나게 신경 써서 이름을 지어야 한다.
- (...) 우리가 가장 많이 사용하는 리팩터링도 함수 선언 바꾸기, 변수 이름 바꾸기, 필드 이름 바꾸기처럼 이름을 바꾸는 리팩터링들이다.
- 마땅한 이름이 더오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다.

알고는 있는데...

## 3.2 중복 코드

- 똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.
- 코드가 비슷하긴 한데 완전히 똑같지는 않다면, 먼저 문장 슬라이드하기로 비슷한 부분을 한 곳에 모아 함수 추출하기를 더 쉽게 적용할 수 있는지 살펴본다.

냄새나는 코드를 제거하기 위해 냄새나는 코드를 한 곳으로 모으기 같은 건가 싶었다. 그렇다면 '문장 슬라이드하기'는 '리팩터링을 위한 리팩터링'으로 쓰일 수도 있을까?

## 3.3 긴 함수

- 간접 호출의 효과, 즉 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것이다.
- 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다. 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다. 그러기 위해서는 훨씬 적극적으로 함수를 쪼개야 한다.
- 함수 이름은 동작 방식이 아닌 의도가 드러나게 짓는다.
- '무엇을 하는지'를 코드가 잘 설명해주지 못할수록 함수로 만드는 게 유리하다.

## 3.4 긴 매개변수 목록

## 3.5 전역 데이터

- 전역 데이터는 코드베이스 어디에서는 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는 게 문제다.

## 3.6 가변 데이터

## 3.7 뒤엉킨 변경

- 우리는 소프트웨어의 구조를 변경하기 쉬운 형태로 조직한다. 소프트웨어는 자고로 소프트해야 마땅하기 때문이다. 코드를 수정할 때는 시스템에서 고쳐야 할 딱 한 군데를 찾아서 그 부분만 수정할 수 있기를 바란다.
- 뒤엉킨 변경은 단일 책임 원칙이 제대로 지켜지지 않을 때 나타난다. 즉, 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다.
- 지원해야 할 데이터베이스가 추가될 때마다 함수 세 개를 바꿔야 하고, 금융 상품이 추가될 때마다 또 다른 함수 네 개를 바꿔야 하는 모듈이 있다면 뒤엉킨 변경이 발생했다는 뜻이다.

## 3.8 산탄총 수술

- 이 냄새는 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 풍긴다.

|           | 뒤엉킨 변경             | 산탄총 수술          |
| --------- | ----------------------- | -------------------- |
| 원인      | 맥락을 잘 구분하지 못함 | (동일)               |
| 해법      | 맥락을 명확히 구분      | (동일)               |
| 발생 과정 | 한 코드에 섞여 들어감   | 여러 코드에 흩뿌려짐 |
| 해법      | 맥락별로 분리           | 맥락별로 모음        |

대부분은 산탄총 수술 냄새가 많이 났던 것 같다. 어설픈 함수 쪼개기의 부작용같은 거라고 해야할지...

## 3.9 기능 편애

- 프로그램을 모듈화할 때는 코드를 여러 영역으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고 영역 사이에서 이뤄지는 상호작용은 최소로 줄이는 데 주력한다.
- 기능 편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을 때 풍기는 냄새다.
- 이 함수가 데이터와 가까이 있고 싶어 한다는 의중이 뚜렷이 드러나므로 소원대로 데이터 근처로 옮겨주면 된다.
- 함수가 사용하는 모듈이 다양하다면 (...) 가장 많은 데이터를 포함한 모듈로 옮긴다. 함수 추출하기로 함수를 여러 조각으로 나눈 후 각각을 적합한 모듈로 옮기면 더 쉽게 해결되는 경우도 많다.

## 3.10 데이터 뭉치

- 필드 형태의 데이터 뭉치를 찾아서 클래스 추출하기로 하나의 객체로 묶는다.
- 매개변수 객체 만들기나 객체 통째로 넘기기를 적용해서 매개변수 수를 줄여본다.
- (값 하나를 삭제 했을 때) 나머지 데이터만으로는 의미가 없다면 객체로 환생하길 갈망하는 데이터 뭉치라는 뜻이다.
- 기능 편애를 없애는 과정에서 새로운 클래스를 만들었다면, 이어서 그 클래스로 옮기면 좋을 동작은 없는지 살펴보자.

## 3.11 기본형 집착

- 이 냄새는 문자열을 다루는 코드에서 특히 흔하다. 전화번호를 단순히 문자 집합으로만 표현하기엔 아쉬움이 많다. 최소한 사용자에게 보여줄 때는 일관된 형식으로 출력해주는 기능이라도 갖춰야 한다.

현재 하고 있는 업무에서 전화번호 형식이 중구난방인데(주로 알림톡 관련 이슈 때문이다. 알림톡 외부 API가 하이픈을 받지 않기 때문), 고쳐야겠다는 생각이 들었다.

## 3.12 반복되는 switch문

- 중복된 `switch`문이 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 `swtich`문들도 모두 찾아서 함께 수정해야 하기 때문이다.

## 3.13 반복문

- 지금은 일급 함수를 지원하는 언어가 많아졌기 때문에 반복문을 파이프라인으로 바꾸기를 적용해서 시대에 걸맞지 않은 반복문을 제거할 수 있게 됐다.

`for await (const item of array)` 같이 순차적으로 실행되어야만 하는 형태가 아니라면 가능한 `map`, `filter`, `reduce`를 쓰려고 노력한다.

요새 가장 자주 쓰는 건 `await Promise.all(array.map(() => {}))`이다. 아무래도 람다 기본 실행 속도 설정이 6초이고, API Gateway 실행 시간 제한이 30초다보니 병렬로 그냥 쭉쭉 실행시키는 게 편하다. 로그 보는 게 좀 불편하다는 게 흠이긴 하다.

## 3.14 성의 없는 요소

- 본문 코드를 그대로 쓰는 것과 진배없는 함수도 있고, 실질적으로 메서드가 하나뿐인 클래스도 있다. (...) 사정이 어떠하든 이런 프로그램 요소는 고이 보내드리는 게 좋다.

어쭙잖게 함수에 역할 하나씩 담는답시고 주화입마에 빠져 `const filterArray = (arr) => arr.filter(() => {})` 같은 코드를 쓰던 예전의 나 자신이 떠올랐다.

## 3.15 추측성 일반화

- 이 냄새는 '나중에 필요할 거야'라는 생각으로 당장은 필요 없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성해둔 코드에서 풍긴다. 그 결과는 물론 이해하거나 관리하기 어려워진 코드다.
- 미래를 대비해 작성한 부분을 실제로 사용하게 되면 다행이지만, 그렇지 않는다면 쓸데없는 낭비일 뿐이다.

## 3.16 임시 필드

- 간혹 특정 상황에서만 값이 설정되는 필드를 가진 클래스도 있다. 하지만 객체를 가져올 때는 당연히 모든 필드가 채워져 있으리라 기대하는 게 보통이라, 이렇게 임시 필드를 갖도록 작성하면 코드를 이해하기 어렵다. 그래서 사용자는 쓰이지 않는 것처럼 보이는 필드가 존재하는 이유를 파악하느라 머리를 싸매게 된다.
