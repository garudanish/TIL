# Chaptor 03. 코드에서 나는 악취

## 3.1 기이한 이름

- 코드는 단순하고 명료하게 작성해야 한다.
- 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 엄청나게 신경 써서 이름을 지어야 한다.
- (...) 우리가 가장 많이 사용하는 리팩터링도 함수 선언 바꾸기, 변수 이름 바꾸기, 필드 이름 바꾸기처럼 이름을 바꾸는 리팩터링들이다.
- 마땅한 이름이 더오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다.

알고는 있는데...

## 3.2 중복 코드

- 똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.
- 코드가 비슷하긴 한데 완전히 똑같지는 않다면, 먼저 문장 슬라이드하기로 비슷한 부분을 한 곳에 모아 함수 추출하기를 더 쉽게 적용할 수 있는지 살펴본다.

냄새나는 코드를 제거하기 위해 냄새나는 코드를 한 곳으로 모으기 같은 건가 싶었다. 그렇다면 '문장 슬라이드하기'는 '리팩터링을 위한 리팩터링'으로 쓰일 수도 있을까?

## 3.3 긴 함수

- 간접 호출의 효과, 즉 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것이다.
- 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다. 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다. 그러기 위해서는 훨씬 적극적으로 함수를 쪼개야 한다.
- 함수 이름은 동작 방식이 아닌 의도가 드러나게 짓는다.
- '무엇을 하는지'를 코드가 잘 설명해주지 못할수록 함수로 만드는 게 유리하다.

## 3.4 긴 매개변수 목록

## 3.5 전역 데이터

- 전역 데이터는 코드베이스 어디에서는 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는 게 문제다.

## 3.6 가변 데이터

## 3.7 뒤엉킨 변경

- 우리는 소프트웨어의 구조를 변경하기 쉬운 형태로 조직한다. 소프트웨어는 자고로 소프트해야 마땅하기 때문이다. 코드를 수정할 때는 시스템에서 고쳐야 할 딱 한 군데를 찾아서 그 부분만 수정할 수 있기를 바란다.
- 뒤엉킨 변경은 단일 책임 원칙이 제대로 지켜지지 않을 때 나타난다. 즉, 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다.
- 지원해야 할 데이터베이스가 추가될 때마다 함수 세 개를 바꿔야 하고, 금융 상품이 추가될 때마다 또 다른 함수 네 개를 바꿔야 하는 모듈이 있다면 뒤엉킨 변경이 발생했다는 뜻이다.

## 3.8 산탄총 수술

- 이 냄새는 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 풍긴다.

|           | 뒤엉킨 변경             | 산탄총 수술          |
| --------- | ----------------------- | -------------------- |
| 원인      | 맥락을 잘 구분하지 못함 | (동일)               |
| 해법      | 맥락을 명확히 구분      | (동일)               |
| 발생 과정 | 한 코드에 섞여 들어감   | 여러 코드에 흩뿌려짐 |
| 해법      | 맥락별로 분리           | 맥락별로 모음        |

대부분은 산탄총 수술 냄새가 많이 났던 것 같다. 어설픈 함수 쪼개기의 부작용같은 거라고 해야할지...

## 3.9 기능 편애

- 프로그램을 모듈화할 때는 코드를 여러 영역으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고 영역 사이에서 이뤄지는 상호작용은 최소로 줄이는 데 주력한다.
- 기능 편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을 때 풍기는 냄새다.
- 이 함수가 데이터와 가까이 있고 싶어 한다는 의중이 뚜렷이 드러나므로 소원대로 데이터 근처로 옮겨주면 된다.
- 함수가 사용하는 모듈이 다양하다면 (...) 가장 많은 데이터를 포함한 모듈로 옮긴다. 함수 추출하기로 함수를 여러 조각으로 나눈 후 각각을 적합한 모듈로 옮기면 더 쉽게 해결되는 경우도 많다.

## 3.10 데이터 뭉치

- 필드 형태의 데이터 뭉치를 찾아서 클래스 추출하기로 하나의 객체로 묶는다.
- 매개변수 객체 만들기나 객체 통째로 넘기기를 적용해서 매개변수 수를 줄여본다.
- (값 하나를 삭제 했을 때) 나머지 데이터만으로는 의미가 없다면 객체로 환생하길 갈망하는 데이터 뭉치라는 뜻이다.
- 기능 편애를 없애는 과정에서 새로운 클래스를 만들었다면, 이어서 그 클래스로 옮기면 좋을 동작은 없는지 살펴보자.

## 3.11 기본형 집착

- 이 냄새는 문자열을 다루는 코드에서 특히 흔하다. 전화번호를 단순히 문자 집합으로만 표현하기엔 아쉬움이 많다. 최소한 사용자에게 보여줄 때는 일관된 형식으로 출력해주는 기능이라도 갖춰야 한다.

현재 하고 있는 업무에서 전화번호 형식이 중구난방인데(주로 알림톡 관련 이슈 때문이다. 알림톡 외부 API가 하이픈을 받지 않기 때문), 고쳐야겠다는 생각이 들었다.

## 3.12 반복되는 switch문

- 중복된 `switch`문이 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 `swtich`문들도 모두 찾아서 함께 수정해야 하기 때문이다.

## 3.13 반복문

- 지금은 일급 함수를 지원하는 언어가 많아졌기 때문에 반복문을 파이프라인으로 바꾸기를 적용해서 시대에 걸맞지 않은 반복문을 제거할 수 있게 됐다.

`for await (const item of array)` 같이 순차적으로 실행되어야만 하는 형태가 아니라면 가능한 `map`, `filter`, `reduce`를 쓰려고 노력한다.

요새 가장 자주 쓰는 건 `await Promise.all(array.map(() => {}))`이다. 아무래도 람다 기본 실행 속도 설정이 6초이고, API Gateway 실행 시간 제한이 30초다보니 병렬로 그냥 쭉쭉 실행시키는 게 편하다. 로그 보는 게 좀 불편하다는 게 흠이긴 하다.

## 3.14 성의 없는 요소

- 본문 코드를 그대로 쓰는 것과 진배없는 함수도 있고, 실질적으로 메서드가 하나뿐인 클래스도 있다. (...) 사정이 어떠하든 이런 프로그램 요소는 고이 보내드리는 게 좋다.

어쭙잖게 함수에 역할 하나씩 담는답시고 주화입마에 빠져 `const filterArray = (arr) => arr.filter(() => {})` 같은 코드를 쓰던 예전의 나 자신이 떠올랐다.

## 3.15 추측성 일반화

- 이 냄새는 '나중에 필요할 거야'라는 생각으로 당장은 필요 없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성해둔 코드에서 풍긴다. 그 결과는 물론 이해하거나 관리하기 어려워진 코드다.
- 미래를 대비해 작성한 부분을 실제로 사용하게 되면 다행이지만, 그렇지 않는다면 쓸데없는 낭비일 뿐이다.

## 3.16 임시 필드

- 간혹 특정 상황에서만 값이 설정되는 필드를 가진 클래스도 있다. 하지만 객체를 가져올 때는 당연히 모든 필드가 채워져 있으리라 기대하는 게 보통이라, 이렇게 임시 필드를 갖도록 작성하면 코드를 이해하기 어렵다. 그래서 사용자는 쓰이지 않는 것처럼 보이는 필드가 존재하는 이유를 파악하느라 머리를 싸매게 된다.

## 3.17 메시지 체인

- 메시지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다. (...) 이는 클라이언트가 객체 내비게이션 구조에 종속됐음을 의미한다. 그래서 내비게이션 중간 단계를 수정하면 클라이언트 코드도 수정해야 한다.
- 다음 코드가 메시지 체인의 전형적인 예다: `managerName = aPerson.department.manager.name;`
  - `managerName = aPerson.department.managerName`
  - `managerName = aPerson.manager.name`
  - `managerName = aPerson.managerName` 등으로 체인을 구성하는 모든 객체에 위임 숨기기를 적용할 수 있다.

## 3.18 중개자

- 캠슐화하는 과정에서는 위임이 자주 활용된다.
- 하지만 지나치면 문제가 된다. 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면 어떤가? 이럴 때는 중개자 제거하기를 활용하여 실제로 일을 하는 객체와 직접 소통하게 하자.

## 3.19 내부자 거래

- 일이 돌아가게 하려면 (데이터) 거래가 이뤄질 수밖에 없지만, 그 양을 최소로 줄이고 모두 투명하게 처리해야 한다.

## 3.20 거대한 클래스

- 한 클래스가 너무 많은 일을 하려다 보면 필드 수가 상당히 늘어난다. 그리고 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉽다.
- 이럴 때는 클래스 추출하기로 필드들 일부를 따로 묶는다. 같은 컴포넌트에 모아두는 것이 합당해 보이는 필드들을 선택하면 된다. 더 일반적으로는, 한 클래스 안에서 접두어나 접미어가 같은 필드들이 함께 추출할 후보들이다.
- 필드가 너무 많은 클래스와 마찬가지로 코드량이 너무 많은 클래스도 중복 코드와 혼동을 일으킬 여지가 크다. 가장 간단한 해법은 그 클래스 안에서 자체적으로 중복을 제거하는 것이다.

NoSQL을 쓰는 현재 상황 상 DB 엔터티가 마구마구 거대해지고 있다. 이걸 좀 해결하고 싶은데, 엄두가 잘 나지 않는다...

## 3.21 서로 다른 인터페이스들의 대안 클래스들

- 클래스를 사용할 때의 큰 장점은 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 것이다. 단, 교체하려면 인터페이스가 같아야 한다.

이 부분은 잘 이해 안 됨...

## 3.22 데이터 클래스

- 데이터 클래스란 데이터 필드와 게터/세터 메서드로만 구성된 클래스를 말한다. 그저 데이터 저장 용도로만 쓰이다 보니 다른 클래스가 너무 깊이까지 함부로 다룰 때가 많다.
- 이런 클래스에 public 필드가 있다면 누가 보기 전에 얼른 레코드 캡슐화하기로 숨기자. 변경하면 안 되는 필드는 세터 제거하기로 접근을 원천 봉쇄한다.
- 데이터 클래스는 필요한 동작이 엉뚱한 곳에 정의돼 있다는 신호일 수 있다. 이런 경우라면 클라이언트 코드를 데이터 클래스로 옮기기만 해도 대폭 개선된다.
- 물론 예외도 있다. 특히 다른 함수를 호출해 얻은 결과 레코드(데이터 객체
  )로는 동작 코드를 넣을 이유가 없다. (...) 이런 데이터 구조는 (적어도 현실에서 활용되는 모습상으로는) 불변이다. 불변 필드는 굳이 캡슐화할 필요가 없고, 불변 데이터로부터 나오는 정보는 게터를 통하지 않고 그냥 필드 자체를 공개해도 된다.

## 3.23 상속 포기

- 서브 클래스는 부모로부터 메서드와 데이터를 물려받는다. 하지만 부모의 유산을 원치 않거나 필요 없다면 어떻게 해야 할까?
- 예전에는 계층구조를 잘못 설계했기 때문으로 봤다. 이 관점에서의 해법은, 먼저 같은 계층에 서브클래스를 하나 새로 만들고, 메서드 내리기와 필드 내리기를 활용해서 물려받지 않을 부모 코드를 모조리 새로 만든 서브클래스로 넘긴다. 그러면 부모에는 공통된 부분만 남는다. 한 걸음 더 나아가서 부모 클래스는 모두 추상 클래스여야 한다고 말하는 사람도 많다.
- 항상 이렇게 해야 한다는 입장은 아니다.
- 일부 동작을 재활용하기 위한 목적으로 상속을 활용하기도 하는데, 실무 관점에서 아주 유용한 방식이다. 솔직히 냄새를 풍기지만, 보통은 참을 만한 경우가 많다.
- 상속 포기 냄새는 서브클래스가 부모의 동작은 필요로하지만 인터페이스는 따르고 싶지 않을 때 특히 심하게 난다. 구현을 따르지 않는 것은 이해할 수 있지만 인터페이스를 다르지 않는다는 것은 상당히 무례한 태도다.

## 3.24 주석

- 주석은 악취가 아닌 향기를 입힌다. 문제는 주석을 탈취제처럼 사용하는 데 있다. 주석이 장황하게 달린 원인이 코드를 잘못 작성했기 때문인 경우가 의외로 많다.
- 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다.
- 뭘 할지 모를 때라면 주석을 달아두면 좋다. 현재 진행 상황뿐만 아니라 확실하지 않은 부분에 주석에 남긴다. 코드를 지금처럼 작성한 이유를 설명하는 용도로 달 수도 있다. 이런 정보는 나중에 코드를 수정해야 할 프로그래머에게, 특히 건망증이 심한 프로그래머에게 도움될 것이다.

![return 문 옆에 각주로 중요함이라고 쓰여있다](https://pbs.twimg.com/media/F5twH1LbkAAux1y?format=png&name=360x360)
