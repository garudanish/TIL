# Chaptor 06. 기본적인 리팩터링

## 6.1 함수 추출하기

- 코드 조각을 찾아 무슨 일을 하는지 파악한 다음, 독립된 함수로 추출하고 목적에 맞는 이름을 붙인다.
- 코드를 언제 독립된 함수로 묶어야 할지에 관한 의견은 수없이 많다. ... '목적과 구현을 분리'하는 방식이 가장 합리적인 기준으로 보인다.
- 이 원칙을 적용한 뒤로는 함수를 아주 짧게, 대체로 단 몇 줄만 담도록 작성하는 습관이 생겼다.
- 짧은 함수의 이점은 이름을 잘 지어야만 발휘되므로 이름 짓기에 특별히 신경 써야 한다.

### 절차

1. 함수를 새로 만들고 목적을 잘 드러내는 이름을 붙인다('어떻게'가 아닌 '무엇을' 하는지가 드러나야 한다).
   1. 이름이 더오르지 않는다면 함수로 추출하면 안 된다는 신호다.
2. 추출할 코드를 원본 함수에서 복사하여 새 함수에 붙여넣는다.
3. 추출한 코드 중 원본 함수의 지역 변수를 참조하거나 추출한 함수의 유효범위를 벗어나는 변수는 없는지 검사한다. 있다면 매개변수로 전달한다.
4. 변수를 다 처리했다면 컴파일한다.
5. 원본 함수에서 추출한 코드 부분을 새로 만든 함수를 호출하는 문장으로 바꾼다(즉, 추출한 함수로 일을 위임한다).
6. 테스트한다.
7. 다른 코드에 방금 추출한 것과 독같거나 비슷한 코드가 없는지 살핀다. 있다면 방금 추출한 새 함수를 호출하도록 바꿀지 검토한다.

- 만약 매개변수에 값을 대입하는 코드를 발견하면 곧바로 그 변수를 쪼개서 임시 변수를 새로 하나 만들어 그 변수에 대입하게 한다.

## 6.2 함수 인라인하기

- 이 책은 목적이 분명히 드러나는 이름의 짤막한 함수를 이용하기를 권한다.
- 하지만 때로는 함수 본문이 이름만큼 명확한 경우도 있다.
- 간접 호출은 유용할 수도 있지만 쓸데없는 간접 호출은 거슬릴 뿐이다.

## 6.3 변수 추출하기

- 변수 추출을 고려한다고 함은 표현식에 이름을 붙이고 싶다는 뜻이다.
- 현재 함수 안에서만 의미가 있다면 변수로 추출하는 것이 좋다. 그러나 함수를 벗어난 넓은 문맥에서까지 의미가 된다면 그 넓은 범위에서 통용되는 이름을 생각해야 한다. 다시 말해 변수가 아닌 (주로) 함수로 추출해야 한다.

## 6.4 변수 인라인하기

- 변수는 함수 안에서 표현식을 가리키는 이름으로 쓰이며, 대체로 긍정적인 효과를 준다. 하지만 그 이름이 원래 표현식과 다를 바 없을 때도 있다. ... 이럴 때는 그 변수를 인라인하는 것이 좋다.

애초에 함수 이름이나 필드 이름이 잘 지어져 있을 때 가능한 방법인듯.

## 6.5 함수 선언 바꾸기

- 함수는 프로그램을 작은 부분으로 나누는 주된 수단이다. 함수 선언은 각 부분이 서로 맞물리는 방식을 표현하며, 실질적으로 소프트웨어 시스템의 구성 요소를 조립하는 연결부 역할을 한다.
- 연결부를 잘 정의하면 시스템에 새로운 부분을 추가하기가 쉬워지는 반면, 잘못 정의하면 지속적인 방해 요인으로 작용하여 소프트웨어 동작을 파악하기 어려워지고 요구사항이 바뀔 때 적절히 수정하기 어렵게 한다.
- 이러한 연결부에서 가장 중요한 요소는 함수의 이름이다.
- 좋은 이름을 떠올리는 데 효과적인 방법이 하나 있다. 바로 주석을 이용해 함수의 목적을 설명해보는 것이다. 그러다 보면 주석이 멋진 이름으로 바뀌어 되돌아올 때가 있다.
- 매개변수는 함수가 외부 세계와 어우러지는 방식을 정의한다. 매개변수는 함수를 사용하는 문맥을 설정한다.
- 동작에 필요한 모듈 수가 줄어들수록 무언가를 수정할 때 머리에 담아둬야 하는 내용도 적어진다.
- 따라서 어떻게 연결하는 것이 더 나은지 더 잘 이해하게 될 때마다 그에 맞게 코드를 개선할 수 있도록 함수 선언 바꾸기 리팩터링과 친숙해져야만 한다.

## 6.6 변수 캡슐화하기

- 접근할 수 있는 범위가 넓은 데이터를 옮길 때는 먼저 그 데이터로의 접근을 독점하는 함수를 만드는 식으로 캡슐화하는 것이 가장 좋은 방법일 때가 많다. 데이터 재구성이라는 어려운 작업을 함수 재구성이라는 더 단순한 작업으로 변환하는 것이다.
- 불변 데이터는 가변 데이터보다 캡슐화할 이유가 적다. ... 원본 데이터를 참조하는 코드를 변경할 필요도 없고, 데이터를 변형시키는 코드를 걱정할 일도 없다. 불변성은 강력한 방부제인 셈이다.
- 기본 캡슐화 기법으로 데이터 구조로의 참조를 캡슐화하면, 그 구조로의 접근이나 구조 자체를 다시 대입하는 행위는 제어할 수 있다. 하지만 필드 값을 변경하는 일은 제어할 수 없다. ... (이를 막는) 가장 간단한 방법은 그 값을 바꿀 수 없게 만드는 것이다. 나는 주로 게터가 데이터의 복제본을 반환하도록 수정하는 식으로 처리한다.

현업에서 클래스 문법을 사용하고 있진 않지만, 뭔가를 처리할 때는 습관적으로 복사해서 처리하고, 되도록 객체의 속성을 직접 변경하는 함수는 작성하고 있지 않다. 다만 객체의 속성을 추가하는 일 정도는 한다.

## 6.7 변수 이름 바꾸기

- 명확한 프로그래밍의 핵심은 이름짓기다. 변수는 프로그래머가 하려는 일에 관해 많은 것을 설명해준다. 단, 이름을 잘 지었을 때만 그렇다.
- 함수 호출 한 번으로 끝나지 않고 값이 영속되는 필드라면 이름에 더 신경 써야 한다.

![프로그래머가 가장 힘들어하는 일](https://blog.kakaocdn.net/dn/ciVulX/btq7CG9BuWX/w7Cpgf9oRf4USdYhcEQZkK/img.png)
~~누군들 안 힘들어하겠나...~~

회사에서도 그랬고, 몇 주 전 트위터에서 한글 변수명 사용을 주제로 바이럴이 돈 적이 있었는데, 결국 변수에 명확한 역할을 부여하려는 차원이면 안될게 없지 않나 싶다.

개인적으로는 변수명을 상세하게 지으려 하다보니 밑도끝도 없이 장황해지는 경우가 많았다.

## 6.8 매개변수 객체 만들기

- 데이터 항목 여러 개가 이 함수에서 저 함수로 함께 몰려다니는 경우를 자주 본다. 나는 이런 데이터 무리를 발견하면 데이터 구조 하나로 모아주곤 한다.
- 데이터 뭉치를 데이터 구조로 묶으면 데이터 사이의 관계가 명확해진다는 이점을 얻는다. 게다가 함수가 이 데이터 구조를 받게 하면 매개 변수 수가 줄어든다.
  - 하지만 어차피 구조분해할당을 하지 않나...
- 이 리팩터링의 진정한 힘은 코드를 더 근본적으로 바꿔준다는 데 있다.

최근 협업에서 코드리뷰로 지적받은 것과 정확히 같은 항목이다.

대부분 백엔드 코드에서는 [RORO 패턴](https://taegon.kim/archives/8058)을 많이 사용하다 보니, 매개변수를 두개 이상 보낼 때는 대부분 구조체로 묶어서 보내긴 한다.

## 6.9 여러 함수를 클래스로 묶기

- 클래스는 데이터와 함수를 하나의 공유 환경으로 묶은 후, 다른 프로그램 요소와 어우러질 수 있도록 그중 일부를 외부에 제공한다.
- 클래스는 객체 지향 언어의 기본인 동시에 다른 패러다임 언어에도 유용하다.
- 클래스로 묶을 때의 두드러진 장점은 클라이언트가 객체의 핵심 데이터를 변경할 수 있고, 파생 객체들을 일관되게 관리할 수 있다는 것이다.
- 한 울타리로 묶을 함수들 중 외부에 공개할 함수가 여러 개일 때는 클래스를 사용할 수밖에 없다.
- 프로그램의 다른 부분에서 데이터를 갱신할 가능성이 꽤 있을 때는 클래스로 묶어두면 큰 도움이 된다.

## 6.10 여러 함수를 변환 함수로 묶기

- (소프트웨어를 통해) 도출된 정보는 여러 곳에서 사용될 수 있는데, 그러다 보면 이 정보가 사용되는 곳마다 같은 도출 로직이 반복되기도 한다. 나는 이런 도출 작업들을 한데로 모아두길 좋아한다. 모아두면 검색과 갱신을 일관된 장소에서 처리할 수 있고 로직 중복도 막을 수 있다.
- 나는 본질은 같고 부가 정보만 덧붙이는 변환 함수의 이름을 `enrich`라고 하고, 형태가 변할 때만 `transform`이라는 이름을 쓴다.
  - 나는 `format` 이라고 하는데...

## 6.11 단계 쪼개기

- 나는 서로 다른 두 대상을 한꺼번에 다루는 코드를 발견하면 각각을 별개 모듈로 나누는 방법을 모색한다. 코드를 수정해야 할 때 두 대상을 동시에 생각할 필요 없이 하나에만 집중하기 위해서다.
- 이렇게 분리하는 가장 간편한 방법 하나는 동작을 연이은 두 단계로 쪼개는 것이다.
- 이때 각 단계는 서로 확연히 다른 일을 수행해야 한다.
- 각 단계는 자신만의 문제에 집중하기 때문에 나머지 단계에 관해서는 자세히 몰라도 이해할 수 있다.

단일 책임 원칙의 다른 말이 아닐까?
