# Chaptor 09. 데이터 조직화

## 9.1 변수 쪼개기

- 변수는 다양한 용도로 쓰인다. 그중 변수에 값을 여러 번 대입할 수밖에 없는 경우도 있다. 루프 변수는 반복문을 한 번 돌 때마다 값이 마뀐다. 수집 변수는 메서드가 동작하는 중간중간 값을 저장한다.
- 그 외에도 변수는 긴 코드의 결과를 저장했다가 나중에 쉽게 참조하려는 목적으로 흔히 쓰인다. 이런 변수에는 값을 단 한 번만 대입해야 한다.
- 대입이 두 번 이상 이뤄진다면 여러 가지 역할을 수행한다는 신호다. 역할이 둘 이상인 변수가 있다면 쪼개야 한다. 예외는 없다. 역할 하나당 변수 하나다.

`let`을 의식적으로 피하고, 린트 룰을 빡세게 쓰면 해결 가능할 것으로 보인다. 요새는 대입 안 하고 `let`으로 선언하면 빨간줄 그어주니까...

## 9.2 필드 이름 바꾸기

- 이름은 중요하다. 그리고 프로그램 곳곳에 쓰이는 레코드 구조체의 필드 이름들은 특히 더 중요하다. 데이터 구조는 프로그램을 이해하는 데 큰 역할을 한다.
- 데이터 구조는 무슨 일이 벌어지는지를 이해하는 열쇠다.

## 9.3 파생 변수를 질의 함수로 바꾸기

- 가변 데이터는 소프트웨어에 문제를 일으키는 가장 큰 골칫거리에 속한다. (...) 가변 데이터를 완전히 배제하기란 현실적으로 불가능할 때가 많지만, 가변 데이터의 유효 범위를 가능한 한 좁혀야 한다고 힘주어 주장해본다.
- 효과가 좋은 방법으로, 값을 쉽게 계산해낼 수 있는 변수들을 모두 제거할 수 있다. 계산 과정을 보여주는 코드 자체가 데이터의 의미를 더 분명히 드러내는 경우도 자주 있으며 변경된 값을 깜빡하고 결과 변수에 반영하지 않는 실수를 막아준다.
- 피연산자 데이터가 불변이라면 계산 결과도 일정하므로 역시 불변으로 만들 수 있다. 그래서 새로운 데이터 구조를 생성하는 변형 연산이라면 비록 계산 코드로 대체할 수 있더라도 그대로 두는 것도 좋다.

## 9.4 참조를 값으로 바꾸기

- 객체를 다른 객체에 중첩하면 내부 객체를 참조 혹은 값으로 취급할 수 있다.
- 참조냐 값이냐의 차이는 내부 객체의 속성을 갱신하는 방식에서 가장 극명하게 드러난다. 참조로 다루는 경우에는 내부 객체는 그대로 둔 채 그 객체의 속성만 갱신하며, 값으로 다루는 경우에는 새로운 속성을 담은 객체로 기존 내부 객체를 통째로 대체한다.
- 필드를 값으로 다룬다면 내부 객체의 클래스를 수정하여 값 객체로 만들 수 있다. 값 객체는 대체로 자유롭게 활용하기 좋은데, 특히 불변이기 때문이다. 일반적으로 불변 데이터 구조는 다루기 더 쉽다.
- 불변 데이터 값은 프로그램 외부로 건네줘도 나중에 그 값이 나 몰래 바뀌어서 내부에 영향을 줄까 염려하지 않아도 된다. 값을 복제해 이곳저곳에서 사용하더라도 서로 간의 참조를 관리하지 않아도 된다. 그래서 값 객체는 분산 시스템과 동시성 시스템에서 특히 유용하다.
- 특정 객체를 여러 객체에서 공유하고자 한다면, 그래서 공유 객체의 값을 변경했을 때 이를 관련 객체 모두에 알려줘야 한다면 공유 객체를 참조로 다뤄야 한다.
- 값 객체로 인정받으려면 동치성을 값 기반으로 평가해야 한다. 이 점에서 자바스크립트는 살짝 아쉬운데, 자바스크립트는 참조 기반 동치성을 값 기반 동치성으로 대체하는 일과 관련하여 언어나 핵심 라이브러리 차원에서 지원해주는 게 없다.

그래서 얼마 안되는 테스트 코드에서 값 동치성을 비교할 땐 jest를 쓴다. `expect().toEqual()` 메서드로 사용가능하다.

## 9.5 값을 참조로 바꾸기

- 하나의 데이터 구조 안에 논리적으로 똑같은 제3의 데이터 구조를 참조하는 레코드가 여러 개 있을 때가 있다.
- 같은 데이터를 여러 벌 복사하는 게 조금 꺼림칙할지 모르지만, 별달리 문제되는 경우는 많지 않아서 흔히 사용하는 방식이다. 복사본이 많이 생겨서 가끔은 메모리가 부족할 수도 있지만, 다른 성능 이슈와 마찬가지로 아주 드문 일이다.
- 논리적으로 같은 데이터를 물리적으로 복제해 사용할 때 가장 크게 문제되는 상황은 그 데이터를 갱신해야 할 때다. 모든 복제본을 찾아서 빠짐없이 갱신해야 하며, 하나라도 놓치면 데이터 일관성이 깨져버린다. 이런 상황이라면 복제된 데이터들을 모두 참조로 바꿔주는 게 좋다.

NoSQL 사용하는 개발자는 웁니다. 반정규화, 비정규화의 단점을 절절히 느끼는 요즘이다.

- 값을 참조로 바꾸면 엔터티 하나당 객체도 단 하나만 존재하게 되는데, 그러면 보통 이런 객체들을 한데 모아놓고 클라이언트들의 접근을 관리해주는 일종의 저장소가 필요해진다. 각 엔터티를 표현하는 객체를 한 번만 만들고, 객체가 필요한 곳에서는 모두 이 저장소로부터 얻어 쓰는 방식이 된다.
  - 객체를 어디에 저장해야 할지는 애플리케이션에 따라 다르겠지만, 간단한 상황이라면 나는 저장소 객체 repository object를 사용하는 편이다.

```js
let _repositoryData;

export function initialize() {
  _repositoryData = {};
  _repositoryData.customers = new Map();
}

export function registerCustomer(id) {
  if (!_repositoryData.customers.has(id)) {
    _repositoryData.customers.set(id, new Customer(id));
  }

  return findCustomer(id);
}

export function findCustomer(id) {
  return _repositoryData.customers.get(id);
}
```

예제 코드가 `Map()`을 쓰고 있어서 좀 반가웠고, `registerCustomer` 함수에서도 `findCustomer` 함수를 분리해서 사용하고 있는 게 눈에 띄었다. 정말 역할 분리에 진심이구나 하는 생각이 들었다. 내가 작성했다면 그냥 `return _repositoryData.customers.get(id);` 했을 것 같다.

## 9.6 매직 리터럴 바꾸기

- 매직 리터럴이란 소스코드에 (보통은 여러 곳에) 등장하는 일반적인 리터럴 값을 말한다.
- 코드를 읽는 사람이 이 값의 의미를 모른다면 숫자 자체로는 의미를 명확히 알려주지 못하므로 매직 리터럴이라 할 수 있다. 의미를 알고 있다고 해도 결국 각자의 머리에서 해석해낸 것일 뿐이라서, 이보다는 코드 자체가 뜻을 분명하게 드러내는 게 좋다.
- 일반적으로는 해당 값이 쓰이는 모든 곳을 적절한 이르므이 상수로 바꿔주는 방법이 가장 좋다. 다른 선택지도 있는데, 그 상수가 특별한 비교 로직에 주로 쓰이는 경우에 고려해볼 수 있는 방법이다. 예컨대 나는 `aValue === "M"`을 `aValue === MALE_GENDER`로 바꾸기 보다는 `isMale(aValue)`라는 함수 호출로 바꾸는 쪽을 선호한다.

여담인데, `const TWO_TIMES_PI = Math.PI * 2;`라고 쓰면 신경쓰이는 건 나뿐일까? `2 * MATH.PI`로 고쳐주고 싶다.
