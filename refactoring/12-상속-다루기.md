# Chaptor 12. 상속 다루기

## 12.1 메서드 올리기

- 중복 코드 제거는 중요하다. 중복된 두 메서드가 당장은 문제없이 동작할지라도 미래에는 벌레가 꼬이는 음식물 쓰레기로 전락할 수 있다. 무언가 중복되었다는 것은 한쪽의 변경이 다른 족에는 반영되지 않을 수 있다는 위험을 항상 수반한다. 그런데 일반적으로는 중복을 찾기가 그리 쉽지 않다는 게 문제다.
- 메서드 올리기를 적용하기 가장 쉬운 상황은 메서드들의 본문 코드가 똑같을 때다. 이럴 땐 그냥 복사해 붙여넣으면 끝이다.
- 메서드 올리기를 적용하기에 가장 이상하고 복잡한 상황은 해당 메서드의 본문에서 참조하는 필드들이 서브클래스에만 있는 경우다. 이런 경우라면 필드들 먼저 슈퍼클래스로 올린 후에 메서드를 올려야 한다.

## 12.2 필드 올리기

- 서브클래스들이 독립적으로 개발되었거나 뒤늦게 하나의 계층구조로 리팩터링된 경우라면 일부 기능이 중복되어 있을 때가 왕왕 있다. 특히 필드가 중복되기 쉽다.
- 이런 필드들은 이름이 비슷한 게 보통이지만, 항상 그런 것은 아니다. 그래서 어떤 일이 벌어지는지를 알아내려면 필드들이 어떻게 이용되는지 분석해봐야 한다. 분석 결과 필드들이 비슷한 방식으로 쓰인다고 판단되면 슈퍼클래스로 끌어올리자.
- 이렇게 하면 두 가지 중복을 줄일 수 있다. 첫째, 데이터 중복 선언을 없앨 수 있다. 둘째, 해당 필드를 사용하는 동작을 서브클래스에서 슈퍼클래스로 옮길 수 있다.

## 12.3 생성자 본문 올리기

- 생성자는 다루기 까다롭다. 일반 메서드와는 많이 달라서, 나는 생성자에서 하는 일에 제약을 두는 편이다.
- 생성자는 할 수 있는 일과 호출 순서에 제약이 있기 대문에 조금 다른 식으로 접근 해야 한다.

## 12.4 메서드 내리기

- 특정 서브클래스 하나(혹은 소수)와만 관련된 메서드는 슈퍼클래스에서 제거하고 해당 서브클래스(들)에 추가하는 편이 깔끔하다. 다만, 이 리팩터링은 해당 기능을 제공하는 서브클래스가 정확히 무엇인지를 호출자가 알고 있을 때만 적용할 수 있다. 그렇지 못한 상황이라면 서브클래스에 따라 다르게 동작하는 슈퍼클래스의 기만적인 조건부 로직을 다형성으로 바꿔야 한다.

## 12.6 타입 코드를 서브클래스로 바꾸기

- 소프트웨어 시스템에서는 비슷한 대상들을 특정 특성에 따라 구분해야 할 때가 자주 있다. (...) 이런 일을 다루는 수단으로는 타입코드 필드가 있다. 타입 코드는 프로그래밍 언어에 따라 열거형이나 심볼, 문자열, 숫자 등으로 표현하며, 외부 서비스가 제공하는 데이터를 다루려 할 때 딸려오는 일이 흔하다.
- 타입 코드만으로도 특별히 불편한 상황은 별로 없지만 그 이상의 무언가가 필요할 때가 있다. 여기서 '그 이상'이라 하면 바로 서브클래스를 가리킨다.

최근 같은 메시지 발송 예약인데, '종료 전 리마인드'냐, '종료 당일 알림'이냐에 따라 알림톡 템플릿이 바뀌면서 변수명을 각각 다르게 써야 했던 업무가 있었다. 시간이 없기도 하고 해서 `type === "REMIND" ? {} : {}` 식으로 작성하고 넘겼는데, 이 부분을 읽고 작성했다면 다르게 작성했을까?

## 12.7 서브클래스 제거하기

- 더 이상 쓰이지 않는 서브클래스와 마주하는 프로그래머는 가치 없는 것을 이해하느라 에너지를 낭비할 것이다. 이런 정도까지 되면 서브클래스를 슈퍼클래스의 필드로 대체해 제거하는 게 최선이다.

## 12.8 슈퍼클래스 추출하기

- 비슷한 일을 수행하는 두 클래스가 보이면 상속 메커니즘을 이용해서 비슷한 부분을 공통의 슈퍼클래스로 옮겨 담을 수 있다.
- 객체 지향을 설명할 때 상속 구조는 '현실 세계에서 활용하는 어떤 분류 체계에 기초하여 구현에 들어가기 앞서 부모 자식 관계를 신중하게 설계해야 한다'라고 이야기하는 사람이 많다. 현실 세계의 이런 분류 체계는 상속을 적용하는 데 힌트가 될 수 있다. 하지만 내 경험에 비춰보자면 상속은 프로그램이 성장하면서 깨우쳐가게 되며, 슈퍼클래스로 끌어올리고 싶은 공통 요소를 찾았을 때 수행하는 사례가 잦았다.

객체 지향 개발을 해본 적은 없지만, 내가 알고 있는 개념과 정확히 반대되는 이야기를 해서 새로웠다. 나는 `객체 지향은 항상 적절한 추상화 단계를 파악하기 위해 설계를 우선해야 하고, 그로 인해 개발 속도가 상대적으로 느려진다.` 정도로 알고 있었다. 그런데 이 설명은 일단 별개의 클래스로 두며 개발하다가, 참을 수 없을 때(삼진 아웃됐을 때) 슈퍼클래스를 만들고, 상속을 활용하는 방식으로 보인다. 새롭고 재밌다.

## 12.9 계층 합치기

- 계층구조도 진화하면서 어떤 클래스와 그 부모가 너무 비슷해져서 더는 독립적으로 존재해야 할 이유가 사라지는 경우가 생기기도 한다. 바로 그 둘을 하나로 합쳐야 할 시점이다.

## 12.10 서브클래스를 위임으로 바꾸기

- 상속에는 단점이 있다. 가장 명확한 단점은 한 번만 쓸 수 있는 카드라는 것이다. 무언가가 달라져야 하는 이유가 여러 개여도 상속에서는 그중 단 하나의 이유만 선택해 기준으로 삼을 수밖에 없다. 예컨대 사람 객체의 동작을 '나이대'와 '소득 수준'에 따라 달리 하고 싶다면 서브클래스는 젊은이와 어르신이 되거나, 혹은 부자와 서민이 되어야 한다. 둘 다는 안 된다.
- 또 다른 문제로, 상속은 클래스들의 관계를 아주 긴밀하게 결합한다. 부모를 수정하면 이미 존재하는 자식들의 기능을 해치기가 쉽기 때문에 각별히 주의해야 한다.
- 위임은 이상의 두 문제를 모두 해결해준다. (...) 서브클래싱(상속) 관련 문제에 직면하게 되면 흔히들 서브클래스를 위임으로 바꾸곤 한다.
- (나는) 처음에는 상속으로 접근한 다음, 문제가 생기기 시작하면 위임으로 갈아탄다.

## 12.11 슈퍼클래스를 위임으로 바꾸기

- 제대로 된 상속이라면 서브클래스가 슈퍼클래스의 모든 기능을 사용함은 물론, 서브클래스의 인스턴스를 슈퍼클래스의 인스턴스로도 취급할 수 있어야 한다. 다시 말해, 슈퍼클래스가 사용되는 모든 곳에서 서브클래스의 인스턴스를 대신 사용해도 이상없이 동작해야 한다.

객체 지향 프로그래밍의 개념이 전혀 없는 채로 읽으니 객체 지향을 이 책으로 배우는 느낌이다.

- 상위 타입의 모든 메서드가 하위 타입에도 적용되고, 하위 타입의 모든 인스턴스가 상위 타입의 인스턴스도 되는 등, 의미상 적합한 조건이라면 상속은 간단하고 효과적인 메커니즘이다. 이런 상황이 변하여 상속이 더는 최선의 방법이 아니게 되면 언제든 이번 리팩터링을 이용해 슈퍼클래스를 위임으로 바꿀 수 있다.
