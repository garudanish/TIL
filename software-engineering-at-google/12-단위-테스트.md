# Chapter 12. 단위 테스트

- 구글에서의 단위 테스트는 단일 클래스나 메서드처럼 범위가 상대적으로 좁은 테스트를 뜻한다.
- 테스트의 가장 중요한 목적은 버그 예방이고, 그 다음은 엔지니어 생산성 개선이다.
  - 대체로 작은 테스트에 속한다. 그래서 개발자들이 수시로 수행하며 피드백을 즉각 얻을 수 있다.
  - 대체로 대상 코드와 동시에 작성할 수 있을만큼 작성하기 쉽다.
  - 빠르게 작성할 수 있으므로 테스트 커버리지를 높이기 좋다.
  - 실패 시 원인을 파악하기 쉽다.
  - 대상 시스템의 사용법과 의도한 동작 방식을 알려주는 문서자료 혹은 예제 코드 역할을 해준다.
- 경험상 구글은 단위 테스트를 80%, 그 외 범위가 더 넓은 테스트를 20% 비중으로 작성하도록 장려한다.
- 유지보수하기 쉬운 테스트는 '그냥 작동하는' 테스트다. 한 번 작성해두면 실패하지 않는 한 엔지니어가 신경 쓸 필요 없고, 실패한다면 원인을 바로 알 수 있는 진짜 버그를 찾았다는 뜻이다.

## 12.1 유지보수하기 쉬워야 한다

- 간단한 기능 하나를 추가하려 했는데 기존 테스트가 다 깨지는 경우가 있다.
- 질 나쁜 테스트는 체크인되기 전에 수정돼야 한다.
  - 버그도 없고 자신의 검증 대상과 관련 없는 변경 때문에 실패하는 깨지기 쉬운 테스트
  - 무엇이 잘못되어 실패했는지, 어떻게 고쳐야 하는지를 파악하기 어려운 불명확한 테스트

## 12.2 깨지기 쉬운 테스트 예방하기

- 깨지기 쉬운 테스트란 실제로는 버그가 없음에도, 심지어 검증 대상 코드와는 관련조차 없는 변경 때문에 실패하는 테스트를 말한다.
- 테스트 스위트가 커질 수록 깨지기 쉬운 테스트로부터 받는 고통이 커진다.

### 12.2.1 변하지 않는 테스트로 만들기 위해 노력하자

- 이상적인 테스트라면 한 번 작성한 후로는 대상 시스템의 요구사항이 바뀌지 않는 한 절대 수정할 일이 없어야 한다.
- 리팩터링, 새 기능 추가, 버그 수정 시에는 기존 테스트를 손볼 일이 없어야 한다.
- 기존 테스트를 수정해야 하는 경우는 시스템의 행위가 달라지는 파괴적인 변경이 일어날 때뿐이다.

#### 순수 리팩터링

- 외부 인터페이스는 놔두고 내부만 리팩터링한다면 테스트는 변경되지 않아야 한다.
- 테스트의 역할은 리팩터링 후에도 시스템의 행위가 달라지지 않았음을 보장하는 것이다.

#### 새로운 기능 추가

- 새로운 기능이나 행위를 추가할 때는 기존 행위들에 영향을 주지 않아야 한다.
- 새 기능을 검증할 테스트를 새로 작성해야 하며, 기존 테스트들은 변경되지 않아야 한다.

#### 버그 수정

- 버그가 존재한다는 것은 기존 테스트 스위트에 빠진 게 있다는 신호다.
- 버그 수정과 동시에 누락됐던 테스트를 추가해야 한다.

#### 행위 변경

- 시스템의 기존 행위를 변경하는 경우로, 기존 테스트 역시 변경되어야 한다.
- 이 경우 테스트를 변경한다는 것은 시스템이 한 약속을 '의도적으로' 변경한다는 뜻이다.

### 12.2.2 공개 API를 이용해 테스트하자

- 테스트도 시스템을 다른 사용자 코드와 똑같은 방식으로 호출해야 한다. 즉, 내부 구현을 위한 코드가 아닌 공개 API를 호출하면 된다.
- 공개되지 않은 메서드를 호출하면 리팩터링을 할 때마다 거의 매번 테스트가 실패하게 된다.
- 공개 API만 이용하는 테스트라면 정의상 대상 시스템을 사용자와 똑같은 방식으로 사용하므로, 더 현실적이고 잘 깨지지 않는다.
- 이 맥락에서 '공개 API'는 코드 소유자가 서드파티에 노출한 API를 뜻한다.
- 어디까지가 공개 API인가를 정하는 일에 과학적인 정답은 없지만 쓸만한 경험법칙은 다음과 같다.
  - 헬퍼 클래스라면 독립된 단위로 생각하지 않는 게 좋다. 이런 메서드나 클래스는 직접 테스트하지 말고 헬퍼 클래스를 사용하는 클래스를 통해 우회적으로 테스트 해야 한다.
  - 소유자의 통제 없이 누구든 접근할 수 있게 설계된 패키지나 클래스라면 거의 예외 없이 직접 테스트해야 하는 단위로 취급해야 한다.
  - 소유자만이 접근할 수 있지만 다방면으로 유용한 기능을 제공하도록 설계된 패키지나 클래스(e.g., 지원 라이브러리) 역시 직접 테스트해야 하는 단위로 봐야 한다.

### 12.2.3 상호작용이 아니라 상태를 테스트하자

- 시스템이 기대한 대로 동작하는지 검증하는 방법은 크게 두 가지이다.
  - 상태 테스트
    - 메서트 호출 후 시스템 자체를 관찰한다.
    - 결과가 무엇이냐를 확인한다.
  - 상호작용 테스트
    - 호출을 처리하는 과정에서 시스템이 다른 모듈(시스템)과 협력해 기대한 일련의 동작을 수행하는지를 확인한다.
    - 결과에 도달하기까지 시스템이 어떻게 작동하냐를 확인한다.
- 대체로 상호작용 테스트는 상태 테스트보다 깨지기 쉽다.
- 상호작용 테스트가 만들어지는 가장 큰 원인은 모의 객체 프레임워크*mocking framework*에 지나치게 의존하기 때문이다.
  - 진짜 객체가 빠르고 결정적이라면 테스트 대역을 지양하고 진짜 객체를 사용해야 한다.

## 12.3 명확한 테스트 작성하기

- 테스트 실패는 엔지니어에게 유용한 신호를 주며 단위 테스트의 존재 가치를 증명하는 가장 주요한 수단 중 하나다.
- 테스트가 실패하는 이유는 크게 두 가지다.
  - 대상 시스템에 문제가 있거나 불완전하다. 이런 실패는 버그를 고치라는 경고다.
  - 테스트 자체에 결함이 있을 수 있다. 이런 실패는 깨지기 쉬운 테스트라는 뜻이다.
- 명확한 테스트는 존재 이유와 실패 원인을 엔지니어가 곧바로 알아차릴 수 있는 테스트다.
- 테스트 스위트를 확장하고 시간이 지나도 유용하길 바란다면 테스트 하나하나가 최대한 명확해야 한다.

### 12.3.1 완전하고 간결하게 만들자

- 완전한 테스트란 결과에 도달하기까지의 논리를 읽는 이가 이해하는 데 필요한 모든 정보를 본문에 담고 있는 테스트다.
- 간결한 테스트란 코드가 산만하지 않고, 관련 없는 정보는 포함하지 않은 테스트다.
- 테스트를 더 명확하게 만들 수 있다면 DRY*Don't Repeat Yourself* 원칙을 거스르는 게 나을 때도 많다.
- '테스트 본문에는 테스트를 이해하는 데 필요한 정보를 모두 담아야 하며, 그와 동시에 눈을 어지럽히거나 관련 없는 정보는 담지 않아야 한다.'

### 12.3.2 메서드가 아니라 행위를 테스트하자

- 메서드 하나에 테스트 메서드 하나씩 두는 방식은 처음엔 편리하지만, 메서드가 복잡해질 수록 테스트도 함께 복잡해진다.
- 메서드 하나의 전반을 검사하다 보면 자연스럽게 불명확한 테스트로 이어진다.
- 테스트를 메서드별로 작성하지 말고 행위별로 작성하는 방법이 더 낫다.
- 행위란 특정 상태에서 특정한 일련의 입력을 받았을 때 시스템이 보장하는 '반응'을 뜻한다.
  - 행위를 때로는 given/when/then을 써서 표현하기도 한다.
- 행위 주도 테스트는 대체로 메서드 중심 테스트보다 명확하다.

#### 테스트의 구조는 행위가 부각되도록 구성하자

- given 요소에는 시스템의 설정을 정의한다.
- when 요소에는 시스템이 수행할 작업을 정의한다.
- then 요소에는 결과를 검증한다.
- 여러 단계로 진행되는 작업을 단계별로 검증하고 싶을 때는 when과 then 블록을 교대로 정의하는 방법도 있다.
  - 테스트 각각은 단 하나의 행위만 다뤄야 하며, 절대다수의 단위 테스트에는 when과 then 블록이 하나씩이면 충분하다.

#### 테스트 이름은 검사하는 행위에 어울리게 짓자

- 메서드 중심 테스트의 이름은 대체로 메서드의 이름을 따서 짓지만, 행위 주도 테스트는 이름 짓기가 자유로워서 더 의미 있는 정보를 담을 수 있다.
- 테스트의 이름은 검사하려는 행위를 요약해 보여줘야 한다. 시스템이 수행하는 동작과 예상 결과를 모두 담아야 좋은 이름이다.
- 잘 작성된 테스트 스위트의 테스트 메서드 이름들을 보면 대상 시스템이 어떤 행위를 구현하고 있는지 쉽게 파악할 수 있다.

### 12.3.3 테스트에 논리를 넣지 말자

- 복잡성은 대체로 논리라는 형태로 나타나고, 논리는 명령형 요소(연산자, 반복문, 조건문 등)를 이용해 표현한다.
- 테스트 코드에서는 스마트한 로직보다 직설적인 코드를 고집해야 한다.

### 12.3.4 실패 메시지를 명확하게 작성하자

- 잘 작성된 실패 메시지라면 '원하는 결과', '실제 결과', '매개변수의 값'을 명확히 알려줘야 한다.
- 좋은 라이브러리를 사용하면 실패 메시지를 쓸모 있게 작성하기가 더 쉬워진다.

## 12.4 테스트와 코드 공유: DRY가 아니라 DAMP

- 테스트 코드에서는 DRY가 주는 혜택이 그리 크지 않다.
- DRY를 고집하는 대신 테스트 코드는 DAMP가 되도록 노력해야 한다.
- DAMP는 서술적이고 의미 있는 문구*Descriptive And Meaningful Phrase*를 뜻한다.
- DAMP는 DRY를 대체하는 것이 아니라 보완해주는 개념이다.
- 테스트에서의 리팩터링은 반복을 줄이는 게 아니라 더 서술적이고 의미있게 하는 방향으로 이루어져야 한다.

### 12.4.1 공유 값

- 필요한 값들을 테스트마다 일일이 준비하려면 장황하고 귀찮기 때문에 상수를 정의해 공유하고 싶은 유혹에 빠질 수 있다.
- 도우미 메서드를 이용해 데이터를 구성하면 불필요한 정보로 오염되거나 다른 테스트와 충돌할 염려 없이 정확히 필요한 값들만 생성해 사용할 수 있다.

### 12.4.2 공유 셋업

- 셋업 메서드를 잘못 사용하면 중요한 세부 정보를 숨겨버려서 테스트가 완벽해지지 못하게 막는다.
- 셋업 메서드가 이용한 특정 값에 의존하는 테스트가 생겨나기 시작하면 악몽이 시작될 수 있다.
- 특정 값을 요구하는 테스트라면 그 값을 직접 기술해야 한다. 필요하다면 셋업 메서드가 정의한 기본값을 덮어써야 한다.

### 12.4.3 공유 도우미 메서드와 공유 검증 메서드

- 여러 테스트에서 똑같은 일련의 단정문들을 반복할 때 도우미 메서드로 옮겨 호출하는 것은 테스트 각각의 의도를 추론해내기가 훨씬 어렵기 때문에 매우 위험하다.
- 하나의 목적에 집중하는 검증 메서드는 여전히 유용하다.
  - 잘 만들어진 검증용 도우미 메서드는 여러 조건을 확인하는 게 아니라 입력에 대한 단 하나의 '개념적 사실'만을 검증한다.

### 12.4.4 테스트 인프라 정의하기

- 테스트 인프라는 다른 테스트 스위트와도 공유하는 코드를 말한다.
- 테스트 인프라는 주로 통합 테스트나 E2E 테스트 때 빛을 발하고, 신중하게 설계한다면 특정 사오항에서는 단위 테스트를 작성하는 데도 큰 도움을 준다.
- 테스트 인프라는 독립된 제품 대우를 해줘야 하며, 자신을 검사해줄 자체 테스트들을 갖추고 있어야 한다.

## 12.5 마치며

- 단위 테스트를 생각 없이 만들면 시스템에 대한 확신을 키워주는 건 고사하고, 시스템을 유지보수하거나 변경하기가 훨씬 어려워진다.

## 12.6 핵심 정리

- 변하지 않는 테스트를 만들기 위해 노력하라.
- 공개 API를 통해 테스트하라.
- 상호작용이 아닌, 상태를 테스트하라.
- 테스트를 완전하고 명확하게 만들어라.
- 메서드가 아닌, 행위를 테스트하라.
- 행위가 부각되게끔 테스트를 구성하라.
- 테스트 이름은 검사하는 행위가 잘 드러나게 지어라.
- 테스트에 로직을 넣지 말라.
- 실패 메시지를 명확하게 작성하라.
- 테스트들이 코드를 공유할 때는 DRY보다 DAMP를 우선하라.
