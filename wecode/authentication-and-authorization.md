# 인증과 인가

## 인증 Authentication

개발자의 입장에서 웹, 서비스를 봤을 때, 우리 서비스를 누가 쓰며 어떻게 사용하고 있는지 추적이 가능하도록 하기 위해 필요하다. 권한 체크, 사용자 식별 등... 다 맞다.

인증에 필요한 것: 아이디, 비밀번호, 이메일... 가장 중요한 것은 password! 슬랙에서 각자의 프로필 눌러보면 이메일 다 볼 수 있다. 이메일도 물론 로그인할 때 사용하지만, 개인을 인증하는데 가장 중요한 것은 패스워드임.

법적으로 개인정보 암호화는 강제되어있다. 개인을 식별할 수 있는 비밀번호, 바이오정보, 주민번호 등은 암호화되어야만 한다. 국가에서 권고하는 상용 암호화 알고리즘을 이용해 개인정보를 암호화하도록 법적으로 요구하고 있다.

데이터베이스에 pw는 절대 원본을 저장하지 않는다. 해선 안 된다! 해싱을 통해 저장해서 원본을 알 수 없게 저장해야 한다.

HTTPS를 통해 통신 시 개인 정보를 주고받을 때 SSL을 적용하여 암호화한다. 통신을 주고받을 때 암호화할 수 있냐 없냐를 가르는 것이 https이다. 로컬에서 개발할 때는 https를 적용하지 않지만, 실제 프로덕션 단계에선 적용해야만 한다. 쉽게 말해 통신을 주고 받는 과정에서 보안 레이어를 하나 더 끼우는 것. 주고받는 사람 끼리만 알 수 있고, 중간에 탈취당하더라도 이미 암호화된 상태이기 때문에 탈취한 것을 활용할 수 없게끔 한다.

### 단방향 해쉬

복원이 불가능한 해쉬 함수. 해쉬된 값에서 원본값을 유추할 수 없다. 즉, 해싱값으로 부터 원본값 복원이 불가능하다. 대표적 예시로 SHA-256이 있다.

**하지만 같은 알고리즘으로 같은 값을 다시 해싱하면 항상 같은 결과가 도출된다는 점이 단방향 해싱의 단점이다.** 1234를 SHA-256를 사용해 해싱했을 때 그 값에서 1234를 알아낼 수는 없지만, 1234를 해싱하면 언제나 같은 값이 나온다.

따라서 가능한 모든 경우의 수를 해시값을 만들어서 판매하는 서비스도 존재한다. 이런 것을 Rainbow Table이라고 한다. 이것을 이용해 해시값을 유추하는 사이트 역시 존재한다. 굉장히 좋은 컴퓨터라면 Rainbow Table을 활용해 원본값을 유추할 수 있을 것이다.

### Salting & KeyStretching

단순 해시값이 해킹에 쉽게 노출되기 때문에 salting이라는 아이디어가 생겼다. 원본 패스워드에 랜덤한 salt값(임의로 생성한 문자열)을 붙인다. '원본 패스워드 + salt'를 해싱해서 이 해시값을 저장하는 방법이다. 물론 이때 원본값을 다시 유추할 수 없기 때문에, 비교를 위해 해시값과 salt 값을 같이 저장해야 한다.

DB에 같은 값으로 비밀번호를 갖고 있는 사람들이 3명이라고 하자. 이때 salt값이 없으면 해싱 값이 똑같으므로, 1명만 보안이 뚫려도 3명이 한꺼번에 털리게 된다.

보안은 완벽할 수 없기 때문에, Salting 및 해싱을 여러번 반복해서 원본 해석에 오랜 시간이 걸리게 하는 방법이 keyStretching이다.

### bcrypt

위의 개념들을 실제로 적용하기 편하게 해주는 대표적인 라이브러리이다. 다양한 언어를 지원하고 사용이 간편해 쉽게 적용이 가능하다. salting, keystretching을 쉽게 적용할 수 있다.

bycrypt는 해싱 결과값에 salt값과 해시값 및 반복횟수를 같이 보관하기 때문에, 비밀번호 해싱을 적용하면서 DB 설계를 복잡하게 할 필요가 없다. 비교할 때도 bcrypt를 사용해서 비교해버리면 된다.

## 인가 Authorization

> 해당 유저가 request에 해당하는 권한이 있는지 확인하는 절차

쿠팡에서 처음 회원가입하고, 로그인하면 인증과정을 거친 것. 나의 주문, 배송목록 조회를 위한 API는 꼭 로그인이 필요하다. 이 로그인을 한 상태인지 따지는 것이 **인가**이다. http는 stateless하기 때문에, 사실 이러한 모든 권한이 필요한 통신을 할 때마다 매번 로그인해야 한다.

매번 로그인 과정을 거치는 건 너무나도 귀찮다! 그렇다면 로그인했다고 기억하게 해주면 된다. 서버는 사용자가 로그인 했을 때, 로그인 했다는 것을 `headers`에 특정 메타데이터를 보내서 확인한다. 이 메타데이터를 JSON Web Token `JWT`이라고 한다.

로그인을 하면 - 서버에서 200 OK와 함께 Token을 발급해주고 - 프론트엔드를 그 토큰을 어디엔가 저장해두고 - 인가가 필요한 과정 때 그 토큰과 함께 요청을 보낸다. 토큰과 함께 요청하는 것만으로 계속 로그인할 필요가 없어지게 된다.

### JSON Web Token

> `aaaaaa.bbbbbb.cccccc`
>
> 헤더.내용.서명

- 헤더 header
  - 토큰의 타입과 해시 알고리즘 정보가 들어간다.
  - 헤더의 내용이 BASE64 방식으로 인코딩해서 JWT의 가장 첫 부분에 기록된다.
  - 인코딩은 암호화가 아니다! 단순 형태 변환이라고 생각을 하면 된다. 암호화가 되지 않았기 때문에 개인정보가 들어가 있지 않다.
- 내용 payload
  - 미리 정의된 집합인 Registered Claim, 공개용 정보 전달을 목적으로 하는 Public Claim, 클라이언트와 서버간 협의 하에 사용하는 Private Claim. 토큰의 만료시간을 나타내는 exp는 Registered Claim에 포함된다.
  - 위 세가지 요소를 조합해서 작성한 뒤 BASE64 인코딩하여 두번째 요소로 위치한다. 즉, 개인정보를 담아선 안 된다.
  - 내용에 각각의 DB에 있는 PK를 담는 건 된다. PK라는 건 서비스마다 존재하는 식별자이다. 쿠팡에서 `user-id`가 `1`이라도, 당근마켓에서 같은 `user-id`를 갖고 있지 않다. 탈취되더라도 다른 데에서 쓸모가 없다.
- 서명 siganature
  - JWT가 원본 그대로라는 것을 확인할 때 사용하는 부분. 위조 토큰이 아니라 진짜 우리 서버에서 발급한 토큰이라는 것을 확인하는 부분.
  - header, payload는 암호화가 아니라 특정 방식으로 인코딩된 부분이다. 시그니쳐는 header와 payload, 별도로 생성한 JWT secret을 헤더에 지정된 암호 알고리즘으로 암호화해 전송한다.
  - 프론트엔드가 JWT를 백엔드 API 서버로 전송하면, 서버에서는 전송받은 JWT의 서명부분을 복호화하여 서버에서 생성한 JWT가 맞는지 확인한다. 서버의 키 값으로 암호화하고, 서버에서 해당 키 값으로 시그니쳐를 복호화했을 때 성공한다면 해당 서버에서 발급한 토큰이라는 점이 확인되는 셈이다.

즉, 주문목록과 같이 토큰을 필요로 하는 사이트에서 새로고침을 계속하면, 복호화 과정이 계속되는 것이다. 물론 풀어서 설명하니까 길어보이지, 컴퓨터가 처리하는 과정은 굉장히 짧을 것...!
