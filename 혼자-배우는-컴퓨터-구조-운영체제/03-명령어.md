# Chapter 03. 데이터

## 3-1. 소스 코드와 명령어

### 고급 언어와 저급 언어

- 우리가 프로그램을 만들 때 사용하는 프로그래밍 언어는 컴퓨터가 이해하는 언어가 아닌, 사람이 이해하고 작성하기 쉽게 마들어진 언어다. 이를 **고급 언어*high-level programming language***라고 한다.
- 컴퓨터가 직접 이해하고 실행할 수 있는 언어를 **저급 언어*low-level programming language***라고 한다.
  - 저급 언어는 명령어로 이루어져 있다.
  - 컴퓨터가 이해하고 실행할 수 있는 언어는 오직 저급 언어 뿐이다.
  - 고급 언어로 작성된 소스 코드가 실행되려면 반드시 저급 언어, 즉 명령어로 변환되어야 한다.
- 저급 언어에는 1) 기계어, 2) 어셈블리어 가 있다.
- 기계어*machine code*는 0과 1의 명령어 비트로 이루어진 언어다.
- 기계어는 인간이 읽으면 그 의미를 이해하기 어렵다. 그래서 이를 읽기 편한 형태로 번역한 언어가 어셈블리어*assembly language*다.
  - 개발자가 어셈블리어를 이용해 복잡한 프로그램을 만들기는 쉽지 않으므로, 고급 언어가 필요하다.
  - 어셈블리어를 읽으면 프로그램이 어떤 절차로 작동하는지를 가장 근본적인 단계에서부터 하나하나 추적하고 관찰할 수 있다.

### 컴파일 언어와 인터프리터 언어

- 고급 언어가 저급 언어로 변환되는 방식으로 1) 컴파일 방식, 2) 인터프리트 방식이 있다.
  - 각 방식으로 작동하는 언어를 1) 컴파일 언어, 2) 인터프리터 언어라고 한다.

#### 컴파일 언어

- 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어
- C가 대표적이다.
- 컴파일러가 소스 코드 내에서 오류를 하나라도 발견하면 그 소스 코드는 컴파일에 실패한다.
- 컴파일러를 통해 저급 언어로 변환된 코드를 목적 코드*object code*라고 한다.

#### 인터프리터 언어

- 인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어
- Python이 대표적이다.
- 인터프리터 언어는 인터프리터가 소스 코드를 한 줄씩 차례로 저급 언어로 변환해 실행한다.
- 소스 코드 전체를 저급 언어로 변환하는 시간을 기다릴 필요가 없다.
- N번째 줄에 문법 오류가 있더라도 N-1번째 줄까지는 올바르게 수행된다.
- 일반적으로 인터프리터 언어가 컴파일 언어보다 느리다.

### 목적 파일 vs 실행 파일

- 목적 코드로 이루어진 파일을 목적 파일이라고 부르고, 실행 코드로 이루어진 파일을 실행 파일이라고 부른다.
- 목적코드가 실행 파일이 되기 위해서는 링킹이라는 작업을 거쳐야 한다.
  - 하나의 소스 코드 안에 다른 소스의 기능을 가져다가 썼다고 했을 때, 이를 목적 코드로 바꿨다고 해서 바로 실행할 수 있는 것은 아니다.
  - 외부 기능들을 연결 짓는 작업이 필요하다. 이 작업이 링킹이다. 이 작업을 거치면 하나의 실행 파일이 만들어진다.

## 3-2. 명령어의 구조

### 연산 코드와 오퍼랜드

- 명령어는 '무엇을 대상으로, 어떤 작동을 수행하라' 라는 구조로 되어 있다.
- 명령어는 연산 코드와 오퍼랜드로 구성되어 있다.
  - 연산 코드*operation code*: 명령어가 수행할 연산
    - 연산자라고도 부른다.
  - 오퍼랜드*operand*: 연산에 사용할 데이터, 또는 연산에 사용할 데이터가 저장된 위치
    - 피연산자라고도 부른다.
  - 연산 코드가 담기는 영역을 연산 코드 필드, 오퍼랜드가 답기는 영역을 오퍼랜드 필드라고 한다.

#### 오퍼랜드

- 숫자와 문자 등을 나타내는 데이터 또는 메모리나 레지스터 주소가 올 수 있다.
- 많은 경우 연산에 사용할 데이터가 저장된 위치, 즉 메모리 주소나 레지스터 이름이 담긴다.
  - 그래서 오퍼랜드 필드를 주소 필드라고 부르기도 한다.
- 오퍼랜드는 명령어 안에 하나도 없을 수도 있고, 한 개만 있을 수도 있고, 두 개 이상이 있을 수도 있다.
  - 오퍼랜드의 개수에 따라 0-주소 명령어, 1-주소 명령어, 2-주소 명령어, 3-주소 명령어.. 등으로 부른다.

#### 연산 코드

- 기본적인 연산 코드 유형은 크게 네 가지로 나눌 수 있다.
  1. 데이터 전송
  2. 산술/논리 연산
  3. 제어 흐름 변경
  4. 입출력 제어

### 주소 지정 방식

- 오퍼랜드 필드에 메모리나 레지스터의 주소를 담는 이유는 명령어 길이 때문이다.
- 연산의 대상이 되는 데이터가 저장된 위치를 유효 주소*effective address*라고 한다.
- 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법을 주소 지정 방식*addressing mode*이라고 한다.

#### 즉시 주소 지정 방식

- 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식
- 표현할 수 있는 데이터의 크기가 작아지는 단점이 있지만, 메모리나 레지스터로부터 데이터를 찾아오는 과정이 없어서 가장 빠르다.

#### 직접 주소 지정 방식

- 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식
- 표현할 수 있는 데이터의 크기가 즉시 주소 지정 방식보다는 더 커졌지만, 여전히 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수만큼 줄어들었다.

#### 간접 주소 지정 방식

- 유효 주소의 주소를 오퍼랜드 필드에 명시하는 방식
- 두 번의 메모리 접근이 필요해 앞선 방법들보다 일반적으로 느리다.

#### 레지스터 주소 지정 방식

- 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법
- 일반적으로 CPU 내부의 레지스터에 접근하므로 직접 주소 지정 방식보다 빠르다. 하지만 표현할 수 있는 레지스터 크기에 제한이 생길 수 있다.

#### 레지스터 간접 주소 지정 방식

- 연산에 사용할 데이터를 메모리에 저장하고, 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법
- 간접 주소 지정 방식과 비슷하지만, 메모리 접근 횟수가 한 번으로 줄어든다.

### 스택과 큐

- 스택: 한쪽 끝이 막혀 있는 통과 같은 저장 공간
  - 나중에 저장한 데이터를 가장 먼저 빼내는 데이터 관리 방식(후입선출, LIFO)
  - 스택에 새로운 데이터를 저장하는 명령어: `PUSH`
  - 스택에 저장된 데이터를 꺼내는 명령어: `POP`
- 큐: 양쪽이 뚫려 있는 통과 같은 저장 공간
  - 가장 먼저 저장된 데이터부터 빼내는 데이터 관리 방식(선입선출, FIFO)
